{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/@types/index.ts", "../../../src/array/sorted.ts", "../../../src/date/index.ts", "../../../src/check/index.ts", "../../../src/array/zip.ts", "../../../src/array/index.ts", "../../../src/diff/index.ts", "../../../src/fuzzy/index.ts", "../../../src/utils/index.ts", "../../../src/inflection/index.ts", "../../../src/template/eval.ts", "../../../src/template/index.ts"],
  "sourcesContent": ["import * as types from \"./@types\";\nimport array from \"./array\";\nimport check from \"./check\";\nimport date from \"./date\";\nimport diff from \"./diff\";\nimport parser from \"./template\";\nimport fuzzy from \"./fuzzy\";\nimport inflection from \"./inflection\";\nimport utils from \"./utils\";\n\nexport default {\n  check,\n  /**\n   * @deprecated change `parser` to `template`\n   */\n  parser,\n  template: parser,\n  inflection,\n  utils,\n  date,\n  fuzzy,\n  array,\n  diff,\n  ...types,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\nexport type ElementType<T> = T extends (infer U)[] ? U : never;\nexport type FlattenArray<T extends unknown[]> = ElementType<T[]>;\nexport type FlattenTuple<T extends unknown[]> = {\n    [K in keyof T]: ElementType<T[K]>;\n};", "import check from \"../check\";\n\nexport type BisectArrayOptions<T> = {\n    key: (a: T) => number,\n    cmp?: (a: T, b: T) => number,\n    asReversed: boolean,\n    items: T[]\n};\n\nexport class BisectArray<TData> extends Array<TData> {\n  constructor(private opts: BisectArrayOptions<TData>) {\n    const items = opts.items;\n    super(...items);\n    if (this.isValidCmp()) {\n      this.sort(this.opts.cmp);\n    } else {\n      this.sort((a, b) => this.opts.key(a) - this.opts.key(b));\n    }\n\n    if (this.opts.asReversed) {\n      this.reverse();\n    }\n  }\n\n  pop(): TData | undefined {\n    return this.isReversed() ? super.pop() : super.shift();\n  }\n\n  push(...items: TData[]): number {\n    for (const item of items) {\n      const index = this.binarySearch(item);\n      this.splice(index, 0, item);\n    }\n    return this.length;\n  }\n\n  private binarySearch(item: TData): number {\n    let left = 0;\n    let right = this.length - 1;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.shouldSwap(this[mid], item)) {\n        left = mid + 1;\n      } else if (this.shouldSwap(item, this[mid])) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return left;\n  }\n\n  private shouldSwap(a: TData, b: TData): boolean {\n    if (this.opts.cmp && this.isValidCmp()) {\n      return this.isReversed() ?  this.opts.cmp(b, a) <= 0 : this.opts.cmp(a, b) <= 0;\n    }\n    const keyA = this.opts.key(a);\n    const keyB = this.opts.key(b);\n    return (this.isReversed() ? keyB - keyA <= 0 : keyA - keyB <= 0);\n  }\n\n  isValidCmp() {\n    return this.opts.cmp && check.isFunction(this.opts.cmp);\n  }\n\n  public isReversed() {\n    return this.opts.asReversed;\n  }\n}\n\nexport class ReverseSortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: true, items});\n  }\n}\n\nexport class SortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: false, items});\n  }\n}\n\nexport class ReverseNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: true, items});\n  }\n}\n\nexport class SortedNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: false, items});\n  }\n}\n\nexport class ReverseStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class SortedStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class ReverseCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}\n\nexport class SortedCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}", "// const subtractSeconds = (date: Date, seconds: number) => {\n//   date.setSeconds(date.getSeconds() - seconds);\n//   return date;\n// };\n\nconst isWeekend = (date: Date) => {\n  const day = date.getDay(); // get day of week as integer (0 - 6)\n  // 0 is Sunday, 6 is Saturday\n  return day === 0 || day === 6;\n};\n\nconst between = (date: Date, startDate: Date, endDate: Date) => {\n  return date >= startDate && date <= endDate;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst parse = (input: any): Date | null => {\n  const inputDate = new Date(input);\n  const isValidDate = !isNaN(inputDate.getTime());\n\n  if (isValidDate) {\n    return inputDate;\n  }\n\n  return null;\n};\n\nexport type TimeUnit =\n  \"years\"\n  | \"year\"\n  | \"months\"\n  | \"month\"\n  | \"days\"\n  | \"day\"\n  | \"hours\"\n  | \"hour\"\n  | \"minutes\"\n  | \"minute\"\n  | \"seconds\"\n  | \"second\";\n\nconst timeSince = (date: Date): [number, TimeUnit] => {\n  const seconds = Math.floor((+new Date() - +date) / 1000);\n  let interval = seconds / 31536000;\n\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"year\" : \"years\"];\n  }\n  interval = seconds / 2592000;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"month\" : \"months\"];\n  }\n\n  interval = seconds / 86400;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"day\" : \"days\"];\n  }\n\n  interval = seconds / 3600;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"hour\" : \"hours\"];\n  }\n\n  interval = seconds / 60;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"minute\" : \"minutes\"];\n  }\n\n  interval = Math.floor(seconds);\n  return [interval, interval === 1 ? \"second\" : \"seconds\"];\n};\n\nexport default {\n  // subtractSeconds,\n  parse,\n  isWeekend,\n  between,\n  timeSince,\n};", "\nimport date from \"../date\";\n\nconst isNumber = (x: unknown): x is number => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n  );\n};\n\nconst isBigInt = (x: unknown): x is bigint => {\n  return (\n    typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: unknown): x is string => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: unknown): x is boolean => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n  );\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst isFunction = (x: unknown): x is Function => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: unknown): x is object => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: unknown): x is null | undefined => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: unknown): x is unknown[] => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: unknown): x is Set<unknown> => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIterable = (x: any): x is Iterable<unknown> => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: unknown): boolean => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return !isNaN(x as any) && !isNaN(parseFloat(x));\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isValidBoolean = (x: any): boolean => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      new Boolean(true),\n      new Boolean(false),\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst valueOf = <T>(x: T): string | number | bigint | boolean | symbol | T => {\n  if (\n    x instanceof Boolean\n    || x instanceof Number\n    || x instanceof String\n    || x instanceof BigInt\n    || x instanceof Symbol\n  ) {\n    if (x.valueOf && isFunction(x.valueOf)) {\n      return x.valueOf();\n    }\n  }\n\n  return x;\n};\n\nconst isTrue = (x: unknown): boolean => {\n  const valueOfX = valueOf(x);\n  if (x === true || valueOfX === true) {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const alts: any[] = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      new Boolean(true),\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (!isNil(valueOfX)) {\n      if (alts.includes(valueOfX)) {\n        return true;\n      }\n\n      if (isString(valueOfX)) {\n        x = valueOfX;\n      }\n    }\n\n    if (isString(x)) {\n      const y = (x as string).trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (y.length <= len && alts.includes(y.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: unknown): boolean => {\n  if (x === false || valueOf(x) === false) {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\nconst isDate = (x: unknown): boolean => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (isString(x) && typeof x === \"string\") {\n    x = x.trim();\n\n    if (!x) {\n      return false;\n    }\n  }\n\n  if (isBoolean(x)) {\n    return false;\n  }\n\n  if (isArray(x) || isSet(x)) {\n    return false;\n  }\n\n  const y = date.parse(x);\n  return !!y;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isError = (x: any, errorLike = false): x is Error => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (x instanceof Error) {\n    return true;\n  }\n\n  if (errorLike && x && x.stack && x.message) {\n    return true;\n  }\n\n  return false;\n};\n\n// @exports\nexport default {\n  isNil,\n  isNumber,\n  isBigInt,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n  isDate,\n  isError,\n};\n", "import { FlattenArray, FlattenTuple } from \"../@types\";\n\nexport function* zip<T extends ArrayLike<unknown>[]>(...args: T): Generator<FlattenTuple<FlattenArray<T>>> {\n  const min = args.reduce((acc, curr) => {\n    const len = curr.length;\n    if (len < acc) {\n      return len;\n    }\n    return acc;\n  }, 0);\n\n  for (let i = 0; i < min; ++i) {\n    yield args.map((arr) => arr[i]) as FlattenTuple<FlattenArray<T>>;\n  }\n}\n", "import * as sorted from \"./sorted\";\nimport { zip } from \"./zip\";\n\nexport default {\n  ...sorted,\n  zip,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * program: \"patienceDiff\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiff( aLines[], bLines[], diffPlusFlag )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *      diffPlusFlag if true, returns additional arrays with the subset of lines that were\n *          either deleted or inserted.  These additional arrays are used by patienceDiffPlus.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLines[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is 0. (Only set when using patienceDiffPlus.)\n *\n */\n\nfunction patienceDiff(aLines: string[], bLines: string[], diffPlusFlag?: boolean) {\n\n  //\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n  // function is used in preparation for determining the longest common\n  // subsequence.  Specifically, it first reduces the array range in question\n  // to unique values.\n  //\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\n  // array index i as the Map value.\n  //\n\n  function findUnique(arr: string[], lo: number, hi: number) {\n\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n\n      const line = arr[i];\n\n      if (lineMap.has(line)) {\n\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n\n      } else {\n\n        lineMap.set(line, {\n          count: 1,\n          index: i\n        });\n\n      }\n\n    }\n\n    lineMap.forEach((val, key, map) => {\n\n      if (val.count !== 1) {\n\n        map.delete(key);\n\n      } else {\n\n        map.set(key, val.index);\n\n      }\n\n    });\n\n    return lineMap;\n\n  }\n\n  //\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n  // down the aArray and bArray ranges first, before then walking the comparison\n  // between the two arrays.\n  //\n  // Returns an ordered Map, with the Map key as the common line between aArray\n  // and bArray, with the Map value as an object containing the array indexes of\n  // the matching unique lines.\n  //\n\n  function uniqueCommon(aArray: string[], aLo: number, aHi: number, bArray: string[], bLo: number, bHi: number) {\n\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key, map) => {\n\n      if (mb.has(key)) {\n\n        map.set(key, {\n          indexA: val,\n          indexB: mb.get(key)\n        });\n\n      } else {\n\n        map.delete(key);\n\n      }\n\n    });\n\n    return ma;\n\n  }\n\n    type LCSResult = {\n        line: string,\n        aIndex: number,\n        bIndex: number,\n        moved?: boolean,\n    };\n\n    //\n    // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n    // and determines the Longest Common Subsequence (LCS).\n    //\n    // Returns an ordered array of objects containing the array indexes of the\n    // matching lines for a LCS.\n    //\n\n    function longestCommonSubsequence(abMap: Map<string, any>) {\n\n      const ja: any[] = [];\n\n      // First, walk the list creating the jagged array.\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      abMap.forEach((val, _key, _map) => {\n\n        let i = 0;\n\n        while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n\n          i++;\n\n        }\n\n        if (!ja[i]) {\n\n          ja[i] = [];\n\n        }\n\n        if (0 < i) {\n\n          val.prev = ja[i - 1][ja[i - 1].length - 1];\n\n        }\n\n        ja[i].push(val);\n\n      });\n\n      // Now, pull out the longest common subsequence.\n\n      let lcs: any[] = [];\n\n      if (0 < ja.length) {\n\n        const n = ja.length - 1;\n        lcs = [ja[n][ja[n].length - 1]];\n\n        while (lcs[lcs.length - 1].prev) {\n\n          lcs.push(lcs[lcs.length - 1].prev);\n\n        }\n\n      }\n\n      return lcs.reverse();\n\n    }\n\n    // \"result\" is the array used to accumulate the aLines that are deleted, the\n    // lines that are shared between aLines and bLines, and the bLines that were\n    // inserted.\n\n    const result: LCSResult[] = [];\n    let deleted = 0;\n    let inserted = 0;\n\n    // aMove and bMove will contain the lines that don't match, and will be returned\n    // for possible searching of lines that moved.\n\n    const aMove: string[] = [];\n    const aMoveIndex: number[] = [];\n    const bMove: string[] = [];\n    const bMoveIndex: number[] = [];\n\n    //\n    // addToResult simply pushes the latest value onto the \"result\" array.  This\n    // array captures the diff of the line, aIndex, and bIndex from the aLines\n    // and bLines array.\n    //\n\n    function addToResult(aIndex: number, bIndex: number) {\n\n      if (bIndex < 0) {\n\n        aMove.push(aLines[aIndex]);\n        aMoveIndex.push(result.length);\n        deleted++;\n\n      } else if (aIndex < 0) {\n\n        bMove.push(bLines[bIndex]);\n        bMoveIndex.push(result.length);\n        inserted++;\n\n      }\n\n      result.push({\n        line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n        aIndex,\n        bIndex,\n      });\n\n    }\n\n    //\n    // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n    // this function might recursively call recurseLCS to further match the lines\n    // between aLines and bLines.\n    //\n\n    function addSubMatch(aLo: number, aHi: number, bLo: number, bHi: number) {\n\n      // Match any lines at the beginning of aLines and bLines.\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n\n        addToResult(aLo++, bLo++);\n\n      }\n\n      // Match any lines at the end of aLines and bLines, but don't place them\n      // in the \"result\" array just yet, as the lines between these matches at\n      // the beginning and the end need to be analyzed first.\n\n      const aHiTemp = aHi;\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n\n        aHi--;\n        bHi--;\n\n      }\n\n      // Now, check to determine with the remaining lines in the subsequence\n      // whether there are any unique common lines between aLines and bLines.\n      //\n      // If not, add the subsequence to the result (all aLines having been\n      // deleted, and all bLines having been inserted).\n      //\n      // If there are unique common lines between aLines and bLines, then let's\n      // recursively perform the patience diff on the subsequence.\n\n      const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n      if (uniqueCommonMap.size === 0) {\n\n        while (aLo <= aHi) {\n\n          addToResult(aLo++, - 1);\n\n        }\n\n        while (bLo <= bHi) {\n\n          addToResult(- 1, bLo++);\n\n        }\n\n      } else {\n\n        recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n\n      }\n\n      // Finally, let's add the matches at the end to the result.\n\n      while (aHi < aHiTemp) {\n\n        addToResult(++aHi, ++bHi);\n\n      }\n\n    }\n\n    //\n    // recurseLCS finds the longest common subsequence (LCS) between the arrays\n    // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n    // recursively performs another LCS search (via addSubMatch), until there are\n    // none found, at which point the subsequence is dumped to the result.\n    //\n\n    function recurseLCS(aLo: number, aHi: number, bLo: number, bHi: number, uniqueCommonMap?: Map<string, any>) {\n\n      const x = longestCommonSubsequence(uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi));\n\n      if (x.length === 0) {\n\n        addSubMatch(aLo, aHi, bLo, bHi);\n\n      } else {\n\n        if (aLo < x[0].indexA || bLo < x[0].indexB) {\n\n          addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n\n        }\n\n        let i;\n        for (i = 0; i < x.length - 1; i++) {\n\n          addSubMatch(x[i].indexA, x[i + 1].indexA - 1, x[i].indexB, x[i + 1].indexB - 1);\n\n        }\n\n        if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n\n          addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n\n        }\n\n      }\n\n    }\n\n    recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n    if (diffPlusFlag) {\n\n      return {\n        lines: result,\n        lineCountDeleted: deleted,\n        lineCountInserted: inserted,\n        lineCountMoved: 0,\n        aMove,\n        aMoveIndex,\n        bMove,\n        bMoveIndex,\n      };\n\n    }\n\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n    };\n\n}\n\n/**\n * program: \"patienceDiffPlus\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiffPlus( aLines[], bLines[] )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLine[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *          moved is true if the line was moved from elsewhere in aLines[] or bLines[].\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is the number of lines that moved.\n *\n */\n\n// function patienceDiffPlus(aLines: string[], bLines: string[]) {\n\n//   const difference = patienceDiff(aLines, bLines, true);\n\n//   let aMoveNext = difference.aMove || [];\n//   let aMoveIndexNext = difference.aMoveIndex || [];\n//   let bMoveNext = difference.bMove || [];\n//   let bMoveIndexNext = difference.bMoveIndex || [];\n\n//   delete difference.aMove;\n//   delete difference.aMoveIndex;\n//   delete difference.bMove;\n//   delete difference.bMoveIndex;\n\n//   let lastLineCountMoved;\n\n//   do {\n\n//     const aMove = aMoveNext;\n//     const aMoveIndex = aMoveIndexNext;\n//     const bMove = bMoveNext;\n//     const bMoveIndex = bMoveIndexNext;\n\n//     aMoveNext = [];\n//     aMoveIndexNext = [];\n//     bMoveNext = [];\n//     bMoveIndexNext = [];\n\n//     const subDiff = patienceDiff(aMove, bMove, false);\n\n//     lastLineCountMoved = difference.lineCountMoved;\n\n//     subDiff.lines.forEach((v, i) => {\n\n//       if (0 <= v.aIndex && 0 <= v.bIndex) {\n\n//         difference.lines[aMoveIndex[v.aIndex]].moved = true;\n//         difference.lines[bMoveIndex[v.bIndex]].aIndex = aMoveIndex[v.aIndex];\n//         difference.lines[bMoveIndex[v.bIndex]].moved = true;\n//         difference.lineCountInserted--;\n//         difference.lineCountDeleted--;\n//         difference.lineCountMoved++;\n\n//       } else if (v.bIndex < 0) {\n\n//         aMoveNext.push(aMove[v.aIndex]);\n//         aMoveIndexNext.push(aMoveIndex[v.aIndex]);\n\n//       } else {\n\n//         bMoveNext.push(bMove[v.bIndex]);\n//         bMoveIndexNext.push(bMoveIndex[v.bIndex]);\n\n//       }\n\n//     });\n\n//   } while (0 < difference.lineCountMoved - lastLineCountMoved);\n\n//   return difference;\n\n// }\n\nconst ___IGNORE = patienceDiff([], [], true);\nexport type PatienceDiffResult = typeof ___IGNORE;\n\nexport type ChangeType = \"deleted\" | \"inserted\" | \"changed\" | \"unknown\";\n\nexport type Change = {\n    lineNumber: number,\n    changeType: ChangeType,\n    lineContent: string,\n    aIndex: number,\n    bIndex: number,\n};\n\nexport type DiffResult = {\n    changes: Change[],\n    deletedCount: number,\n    insertedCount: number,\n    movedCount: number,\n    linedMovedFromA: string[],\n    linesMovedFromB: string[],\n    _diff: PatienceDiffResult,\n};\n\nconst compare = (a: string, b: string): DiffResult => {\n  const desc = patienceDiff(a.split(\"\\n\"), b.split(\"\\n\"), true);\n\n  const changes: Change[] = desc.lines.map((line, index) => {\n    let changeType: ChangeType = \"unknown\";\n    if (line.aIndex >= 0 && line.bIndex < 0) {\n      changeType = \"deleted\";\n    } else if (line.aIndex < 0 && line.bIndex >= 0) {\n      changeType = \"inserted\";\n    } else if (line.aIndex >= 0 && line.bIndex >= 0) {\n      changeType = \"changed\";\n    }\n\n    return {\n      changeType,\n      lineNumber: index + 1,\n      lineContent: line.line,\n      aIndex: line.aIndex,\n      bIndex: line.bIndex,\n    };\n  });\n\n  return {\n    changes,\n    deletedCount: desc.lineCountDeleted,\n    insertedCount: desc.lineCountInserted,\n    movedCount: desc.lineCountInserted,\n    linedMovedFromA: desc.aMove || [],\n    linesMovedFromB: desc.bMove || [],\n    _diff: desc,\n  };\n};\n\nexport default {\n  compare,\n};", "import { ReverseSortedArray } from \"../array/sorted\";\n\n\n/**\n * Compares the similarity between two strings using an n-gram comparison method.\n * The grams default to length 2.\n * @param str1 The first string to compare.\n * @param str2 The second string to compare.\n * @param gramSize The size of the grams. Defaults to length 2.\n */\nconst similarity = (str1: string, str2: string, gramSize = 2) => {\n  const getNGrams = (s: string, len: number) => {\n    s = \" \".repeat(len - 1) + s.toLowerCase() + \" \".repeat(len - 1);\n    const v = new Array(s.length - len + 1);\n    for (let i = 0; i < v.length; i++) {\n      v[i] = s.slice(i, i + len);\n    }\n    return v;\n  };\n\n  if (!str1?.length || !str2?.length) { return 0.0; }\n\n  // Order the strings by length so the order they're passed in doesn't matter\n  // and so the smaller string's ngrams are always the ones in the set\n  const s1 = str1.length < str2.length ? str1 : str2;\n  const s2 = str1.length < str2.length ? str2 : str1;\n\n  const pairs1 = getNGrams(s1, gramSize);\n  const pairs2 = getNGrams(s2, gramSize);\n  const set = new Set<string>(pairs1);\n\n  const total = pairs2.length;\n  let hits = 0;\n  for (const item of pairs2) {\n    if (set.delete(item)) {\n      hits++;\n    }\n  }\n  return hits / total;\n};\n\n/**\n *\n * Sorts an array in place based on similarity. This method mutates the array and returns a reference to the same array.\n * @param value string that will be used to compare similarity\n * @param topK return top k matches\n * @param gramSize The size of the grams. Defaults to length 2.\n * @param values array to sort\n * @param key Function used to get the value to sort by\n * @returns a reference to the same array which was sorted in place.\n */\nconst topSimilar = <T = string>(value: T, values: T[], key: (obj: T) => string, topK = 5, thresh = 0.35, gramSize = 2) => {\n  const str1 = key(value);\n  if (topK <= 0) {\n    topK = 5;\n  }\n\n  const keysim = new Map<string, number>();\n  const arr = new ReverseSortedArray((x: T) => {\n    const value = key(x);\n    const cachedScore = keysim.get(value);\n    const score = cachedScore || similarity(str1, value, gramSize);\n    if (cachedScore === undefined) {\n      keysim.set(value, score);\n    }\n    return score;\n  });\n  values.forEach((x) => {\n    const score = similarity(str1, key(x), gramSize);\n    if (score >= thresh) {\n      arr.push(x);\n\n      if (arr.length > topK) {\n        const popped = arr.pop();\n\n        if (popped) {\n          keysim.delete(key(popped));\n        }\n      }\n    }\n  });\n\n  return [...arr];\n};\n\nexport default {\n  similarity,\n  topSimilar,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport check from \"../check\";\n\nconst hashCode = (str: any, coerceToString = true): number | null => {\n\n  if (coerceToString) {\n    if (!check.isString(str)) {\n      if (check.isSet(str)) {\n        str = Array.from(str);\n      }\n\n      if (check.isObject(str)) {\n        try {\n          str = JSON.stringify(str);\n        } catch (ignored) {\n          const circularReference: any[] = [];\n          const jsonString = JSON.stringify(str, (key, value) => {\n            if (typeof value === \"object\" && value !== null) {\n              if (circularReference.includes(value)) {\n                return \"[Circular]\";\n              }\n              circularReference.push(value);\n            }\n            return value;\n          });\n\n          // Replace circular references with actual object reference\n          str = jsonString.replace(/\"\\[Circular\\]\"/g, () => {\n            return JSON.stringify(\"[Circular]\");\n          });\n        }\n      }\n\n      if (!check.isString(str) && str.toString) {\n        str = str.toString();\n      }\n    }\n  }\n\n  if (!check.isString(str)) {\n    return null;\n  }\n\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nconst capitalize = (str: string) => {\n  if (!check.isString(str)) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport default {\n  hashCode,\n  capitalize,\n};", "\n// This code is a port of (i.e., based on) the inflection project (https://github.com/jpvanhal/inflection),\n// which is licensed under the MIT License.\n// Copyright (C) 2012-2020 Janne Vanhala\n\nimport utils from \"../utils\";\n\n\nexport type RegexReplaceList = [RegExp, string][]\n\nconst PLURALS: RegexReplaceList = [\n  [/(quiz)$/i, \"$1zes\"],\n  [/^(oxen)$/i, \"$1\"],\n  [/^(ox)$/i, \"$1en\"],\n  [/(m|l)ice$/i, \"$1ice\"],\n  [/(m|l)ouse$/i, \"$1ice\"],\n  [/(passer)s?by$/i, \"$1sby\"],\n  [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n  [/(x|ch|ss|sh)$/i, \"$1es\"],\n  [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n  [/(hive)$/i, \"$1s\"],\n  [/([lr])f$/i, \"$1ves\"],\n  [/([^f])fe$/i, \"$1ves\"],\n  [/sis$/i, \"ses\"],\n  [/([ti])a$/i, \"$1a\"],\n  [/([ti])um$/i, \"$1a\"],\n  [/(buffal|potat|tomat)o$/i, \"$1oes\"],\n  [/(bu)s$/i, \"$1ses\"],\n  [/(alias|status)$/i, \"$1es\"],\n  [/(octop|vir)i$/i, \"$1i\"],\n  [/(octop|vir)us$/i, \"$1i\"],\n  [/^(ax|test)is$/i, \"$1es\"],\n  [/s$/i, \"s\"],\n  [/$/i, \"s\"],\n];\n\nconst SINGULARS: RegexReplaceList = [\n  [/(database)s$/i, \"$1\"],\n  [/(quiz)zes$/i, \"$1\"],\n  [/(matr)ices$/i, \"$1ix\"],\n  [/(vert|ind)ices$/i, \"$1ex\"],\n  [/(passer)sby$/i, \"$1by\"],\n  [/^(ox)en/i, \"$1\"],\n  [/(alias|status)(es)?$/i, \"$1\"],\n  [/(octop|vir)(us|i)$/i, \"$1us\"],\n  [/^(a)x[ie]s$/i, \"$1xis\"],\n  [/(cris|test)(is|es)$/i, \"$1is\"],\n  [/(shoe)s$/i, \"$1\"],\n  [/(o)es$/i, \"$1\"],\n  [/(bus)(es)?$/i, \"$1\"],\n  [/(m|l)ice$/i, \"$1ouse\"],\n  [/(x|ch|ss|sh)es$/i, \"$1\"],\n  [/(m)ovies$/i, \"$1ovie\"],\n  [/(s)eries$/i, \"$1eries\"],\n  [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n  [/([lr])ves$/i, \"$1f\"],\n  [/(tive)s$/i, \"$1\"],\n  [/(hive)s$/i, \"$1\"],\n  [/([^f])ves$/i, \"$1fe\"],\n  [/(t)he(sis|ses)$/i, \"$1hesis\"],\n  [/(s)ynop(sis|ses)$/i, \"$1ynopsis\"],\n  [/(p)rogno(sis|ses)$/i, \"$1rognosis\"],\n  [/(p)arenthe(sis|ses)$/i, \"$1arenthesis\"],\n  [/(d)iagno(sis|ses)$/i, \"$1iagnosis\"],\n  [/(b)a(sis|ses)$/i, \"$1asis\"],\n  [/(a)naly(sis|ses)$/i, \"$1nalysis\"],\n  [/([ti])a$/i, \"$1um\"],\n  [/(n)ews$/i, \"$1ews\"],\n  [/(ss)$/i, \"$1\"],\n  [/s$/i, \"\"],\n];\n\nconst UNCOUNTABLES = new Set([\n  \"equipment\",\n  \"fish\",\n  \"information\",\n  \"jeans\",\n  \"money\",\n  \"rice\",\n  \"series\",\n  \"sheep\",\n  \"species\",\n]);\n\n\n/**\n\nA convenience function to add appropriate rules to plurals and singular\nfor irregular words.\n\n@param singular: irregular word in singular form\n@param plural: irregular word in plural form\n */\nconst _irregular = (singular: string, plural: string): void => {\n  const caseinsensitive = (x: string): string => {\n    return Array\n      .from(x)\n      .map((char) => \"[\" + char + char.toUpperCase() + \"]\")\n      .join(\"\");\n  };\n\n  const insert = (arr: RegexReplaceList, index: number, elem: [string, string]) => {\n    arr.splice(index, 0, [new RegExp(elem[0], \"i\"), elem[1]]);\n  };\n\n  const pluralInsert = (index: number, elem: [string, string]) => {\n    insert(PLURALS, index, elem);\n  };\n\n  const singularInsert = (index: number, elem: [string, string]) => {\n    insert(SINGULARS, index, elem);\n  };\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    pluralInsert(0, [\n      `(${singular[0]})${singular.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + singular.slice(1)\n    ]);\n  } else {\n    pluralInsert(0, [\n      `${singular[0].toUpperCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${singular[0].toLowerCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toUpperCase() + singular.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toLowerCase() + singular.slice(1)\n    ]);\n  }\n};\n\nconst camelize = (string: string, uppercaseFirstLetter = true): string => {\n  const camelCase = dasherize(string)\n    .replace(/-/, \" \")\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n\n  const result = uppercaseFirstLetter\n    ? camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\n    : camelCase;\n\n  return result;\n};\n\n/** Replace underscores with dashes in the string.\n Example: dasherize(\"puni_puni\") returns 'puni-puni'\n */\nconst dasherize = (word: string): string => {\n  return word.replace(/_/g, \"-\");\n};\n\n/**\n  Capitalize the first word and turn underscores into spaces and strip a\n  trailing \"_id\", if any. Like titleize, this is meant for creating pretty output.\n\n  Examples:\n\n  >>> humanize(\"employee_salary\")\n  'Employee salary'\n  >>> humanize(\"author_id\")\n  'Author'\n  */\nconst humanize = (word: string): string => {\n  word = word.replace(/_id$/i, \"\");\n  word = word.replace(/_/g, \" \");\n  word = word.replace(/([a-z\\d]*)/g, (m) => {\n    return m.toLowerCase();\n  });\n  word = word.replace(/^\\w/, (m) => {\n    return m.toUpperCase();\n  });\n  return word;\n};\n\n/**\n  Return the suffix that should be added to a number to denote the position\n  in an ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n  Examples:\n  >>> ordinal(1)\n  'st'\n  >>> ordinal(2)\n  'nd'\n  >>> ordinal(1002)\n  'nd'\n  >>> ordinal(1003)\n  'rd'\n  >>> ordinal(-11)\n  'th'\n  >>> ordinal(-1021)\n  'st'\n  */\nconst ordinal = (number: string | number): string => {\n  number = typeof number === \"number\" ? number : parseInt(number);\n  const n = Math.abs(number);\n  if ([11, 12, 13].includes(n % 100)) {\n    return \"th\";\n  } else {\n    switch (n % 10) {\n    case 1:\n      return \"st\";\n    case 2:\n      return \"nd\";\n    case 3:\n      return \"rd\";\n    default:\n      return \"th\";\n    }\n  }\n};\n\n/**\n  Turn a number into an ordinal string used to denote the position in an\n  ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n  Examples:\n\n  >>> ordinalize(1)\n  '1st'\n  >>> ordinalize(2)\n  '2nd'\n  >>> ordinalize(1002)\n  '1002nd'\n  >>> ordinalize(1003)\n  '1003rd'\n  >>> ordinalize(-11)\n  '-11th'\n  >>> ordinalize(-1021)\n  '-1021st'\n  */\nconst ordinalize = (number: string | number) => {\n  return number.toString() + ordinal(number);\n};\n\nconst parameterize = (string: string, separator = \"-\") => {\n  const cleaned = transliterate(string);\n  let param = cleaned.replace(/[^\\d\\w-]+/gmi, separator);\n  if (separator !== \"\") {\n    while (param.startsWith(separator)) {\n      param = param.slice(separator.length);\n    }\n\n    while (param.endsWith(separator)) {\n      param = param.slice(0, param.length - separator.length);\n    }\n  }\n  return param.toLowerCase();\n};\n\nconst pluralize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  const endsWithLetter = /[A-Za-z]$/.test(word);\n  if (!word || UNCOUNTABLES.has(word.toLowerCase()) || !endsWithLetter) {\n    return word;\n  }\n\n  for (const elem of PLURALS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n\n  return word;\n};\n\nconst singularize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  for (const u of UNCOUNTABLES) {\n    const regex = new RegExp(`\\\\b${u}\\\\b`, \"i\");\n    if (regex.test(word)) {\n      return word;\n    }\n  }\n\n  for (const elem of SINGULARS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n  return word;\n};\n\nconst tableize = (word: string): string => {\n  return pluralize(underscore(word));\n};\n\nconst titleize = (word: string) => {\n  return humanize(underscore(word))\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n};\n\n\nconst transliterate = (string: string) => {\n  const normalized = string.normalize(\"NFKD\");\n  return normalized\n    .replace(/[\\u0300-\\u036f]/g, \"\") // remove combining diacritical marks\n    // eslint-disable-next-line no-control-regex\n    .replace(/[^\\x00-\\x7F]/g, \"\") // remove non-ASCII characters\n    .trim();\n};\n\nconst underscore = (word: string) => {\n  let underscored = word.replace(/([a-z\\d])([A-Z])/g, \"$1_$2\"); // split camelCase\n  underscored = underscored.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\"); // split PascalCase\n  underscored = underscored.replace(/-/g, \"_\"); // replace hyphens with underscores\n  return underscored.toLowerCase();\n};\n\n_irregular(\"person\", \"people\");\n_irregular(\"man\", \"men\");\n_irregular(\"human\", \"humans\");\n_irregular(\"child\", \"children\");\n_irregular(\"sex\", \"sexes\");\n_irregular(\"move\", \"moves\");\n_irregular(\"cow\", \"kine\");\n_irregular(\"zombie\", \"zombies\");\n_irregular(\"slave\", \"slaves\");\n_irregular(\"this\", \"this\");\n_irregular(\"flour\", \"flour\");\n_irregular(\"milk\", \"milk\");\n_irregular(\"water\", \"water\");\n_irregular(\"reserve\", \"reserves\");\n_irregular(\"gas\", \"gasses\");\n_irregular(\"bias\", \"biases\");\n_irregular(\"atlas\", \"atlases\");\n_irregular(\"goose\", \"geese\");\n_irregular(\"pasta\", \"pastas\");\n_irregular(\"slice\", \"slices\");\n_irregular(\"cactus\", \"cacti\");\n\nexport default {\n  camelize,\n  dasherize,\n  humanize,\n  ordinal,\n  ordinalize,\n  parameterize,\n  pluralize,\n  singularize,\n  tableize,\n  titleize,\n  transliterate,\n  underscore,\n\n  UNCOUNTABLES,\n  PLURALS,\n  SINGULARS,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM),\n// which is licensed under the MIT License.\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport { type AnyFn } from \"../@types\";\nimport check from \"../check\";\nimport fuzzy from \"../fuzzy\";\nimport inflection from \"../inflection\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n\n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          // throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n          return {\n            \"kind\": \"symbol\",\n            \"payload\": {\n              \"value\": token\n            }\n          };\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport type EvalWarningMeta = {\n  timestamp: Date,\n  message: string\n};\n\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}, warnings: EvalWarningMeta[] = []): any => {\n  console.assert(check.isObject(expr));\n\n  const warnings_push = (message: string) => {\n    warnings.push({\n      timestamp: new Date(),\n      message,\n    });\n  };\n\n  const recommend = (ctxKey: keyof EvalContext, value: string): string[] => {\n    return fuzzy.topSimilar(\n      value,\n      [...Object.keys(ctx[ctxKey] || {})],\n      (x) => x,\n      5,\n    )\n      .map((str) => {\n        return str.replace(\n          /[\\u00A0-\\u9999<>&]/g,\n          (i) => \"&#\" + i.charCodeAt(0) + \";\"\n        );\n      });\n  };\n\n  const singularOrPlural = (word: string, count: number) => {\n    return count > 1 ? inflection.pluralize(word) : inflection.singularize(word);\n  };\n\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\") && !/^\\$\\d/.test(value)) {\n        const similarNames = recommend(\"vars\", value);\n        const typeName = singularOrPlural(\"variable\", similarNames.length);\n        const areIs = similarNames.length > 1 ? \"are\" : \"is\";\n        const recommendations = ` The most similar ${typeName} ${areIs} ${similarNames.join(\", \")}`;\n        warnings_push(\"Unknown variable '\" + value + \"'.\" + (similarNames.length > 0 ? recommendations : \"\"));\n\n        if (value in (ctx.funcs || {})) {\n          warnings_push(\"'\" + value + \"' is defined as a function.\");\n        }\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\") && !/^\\$\\d/.test(name)) {\n      const similarNames = recommend(\"funcs\", name);\n      const typeName = singularOrPlural(\"function\", similarNames.length);\n      const areIs = similarNames.length > 1 ? \"are\" : \"is\";\n      const recommendations = ` The most similar ${typeName} ${areIs} ${similarNames.join(\", \")}`;\n      warnings_push(\"Unknown function '\" + name + \"'.\" + (similarNames.length > 0 ? recommendations : \"\"));\n\n      if (name in (ctx.vars || {})) {\n        warnings_push(\"'\" + name + \"' is defined as a variable.\");\n      }\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, type EvalWarningMeta, Lexer, parseExpr, runExpr } from \"./eval\";\nimport { AnyFn, type TypeOf } from \"../@types\";\nimport date from \"../date\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nexport type ParserLogsLevel = \"WARN\" | \"ERROR\";\nexport type ParserLog = EvalWarningMeta & {\n  level: \"WARN\" | \"ERROR\",\n  lineNumber: number,\n  error?: Error,\n};\n\nexport type ParseTemplateResult = {\n  result: string,\n  logs: ParserLog[],\n};\n\n/**\n *\n * @param sentence sentence\n * @param _ctx context\n * @returns evaludated sentence\n *\n * @deprecated use `class TemplateParser` or `lval` function\n */\nconst parseTemplate = (sentence: string, _ctx: EvalContext = {}): ParseTemplateResult => {\n  const logs: ParserLog[] = [];\n\n  const result = sentence\n    .split(\"\\n\")\n    .map((line, index) => {\n      try {\n        const parsed = _parseTemplate(line, _ctx);\n        logs.push(...parsed.warnings.map((wranMeta) => ({\n          lineNumber: index + 1,\n          level: \"WARN\" as const,\n          ...wranMeta,\n        })));\n\n        return parsed.result;\n      } catch (error: any) {\n\n        if (error.message.toLowerCase().startsWith(\"no primary expression starts with ')'\") || error.message.startsWith(\"Expected ')' but got '\")) {\n          const modded = line.replace(/(\\W)\\(([^)]+)\\)/g, \"$1 <parentheses> $2 </parentheses>\");\n\n          try {\n            const parsed = _parseTemplate(modded, _ctx);\n            logs.push(...parsed.warnings.map((wranMeta) => ({\n              lineNumber: index + 1,\n              level: \"WARN\" as const,\n              ...wranMeta,\n            })));\n            return parsed\n              .result\n              .replace(/<parentheses> /gi, \"(\")\n              .replace(/ <\\/parentheses>/gi, \")\");\n          } catch (ignored) { /* emtpy */ }\n        }\n\n        let message = \"\";\n\n        if (error) {\n          message = error.message;\n          if (!message && error.toString) {\n            message = error.toString();\n          }\n        }\n\n        if (!message) {\n          message = `${error}`;\n        }\n\n        logs.push({\n          lineNumber: index + 1,\n          level: \"ERROR\",\n          message,\n          error,\n          timestamp: new Date(),\n        });\n      }\n\n      return line;\n    })\n    .join(\"\\n\");\n  return {\n    result,\n    logs,\n  };\n};\n\nconst _parseTemplate = (sentence: string, _ctx: EvalContext = {}) => {\n  const warnings: EvalWarningMeta[] = [];\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      let isParenOpen = word.endsWith(\"(\");\n      let isParenClose = word.endsWith(\")\");\n      let isGt = word.endsWith(\">\");\n      let isLt = word.endsWith(\"<\");\n      while (word && (isPeriod || isExcla || isParenOpen || isParenClose || isGt || isLt)) {\n        word = word.substring(0, word.length - 1);\n\n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        } else if (isParenOpen) {\n          cutHist.push(\"(\");\n        } else if (isParenClose) {\n          cutHist.push(\")\");\n        } else if (isGt) {\n          cutHist.push(\">\");\n        } else if (isLt) {\n          cutHist.push(\"<\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n        isParenOpen = word.endsWith(\"(\");\n        isParenClose = word.endsWith(\")\");\n        isGt = word.endsWith(\">\");\n        isLt = word.endsWith(\"<\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }\n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx, /*&mut*/warnings);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n\n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && ![\"!\", \".\", \",\"].includes(lex.nextToken() as string)) {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return {\n    result: builder.join(\"\").trim(),\n    warnings,\n  };\n};\n\nexport type Context = EvalContext;\nexport type TemplateParserOptions = {\n  includeBuiltIns: boolean,\n};\nclass TemplateParser {\n  constructor(\n    public options: TemplateParserOptions = {\n      includeBuiltIns: true,\n    },\n    public ctx: Context = {},\n    public logs: ParserLog[] = [],\n  ) {\n\n    if (this.options.includeBuiltIns) {\n      this.ctx.funcs = {\n        ...this.builtinFunctions(),\n        ...(this.ctx.funcs || {}),\n      };\n    }\n  }\n\n  builtinFunctions() {\n    const $abs = (x: any): number => Math.abs(x);\n    const $all = (...args: any[]): boolean => {\n      return args.map($bool).every((x) => x === true);\n    };\n    const $any = (...args: any[]): boolean => {\n      return args.map($bool).some((x) => x === true);\n    };\n\n    const $bool = (x: any): boolean => {\n      if (check.isValidBoolean(x)) {\n        return check.isTrue(x);\n      }\n\n      return !!x && $isset(x);\n    };\n    const $float = (x: any): number => parseFloat(x);\n    const $str = (x: any): string => {\n      if ($isnil(x)) {\n        return `${x}`;\n      }\n\n      if (check.isObject(x)) {\n\n        try {\n          x = JSON.stringify(x);\n        } catch (ignored) {\n          const circularReference: any[] = [];\n          const jsonString = JSON.stringify(x, (key, value) => {\n            if (typeof value === \"bigint\") {\n              return value.toString();\n            }\n            if (typeof value === \"object\" && value !== null) {\n              if (circularReference.includes(value)) {\n                return \"[Circular]\";\n              }\n              circularReference.push(value);\n            }\n            return value;\n          });\n\n          // Replace circular references with actual object reference\n          x = jsonString.replace(/\"\\[Circular\\]\"/g, () => {\n            return JSON.stringify(\"[Circular]\");\n          });\n        }\n      }\n\n      if (!check.isString(x)) {\n        x = x.toString ? x.toString() : `${x}`;\n      }\n\n      return x;\n    };\n\n    const $format = (fmt: string, ...args: any[]): string => {\n      if (!check.isString(fmt) || args.length === 0) {\n        return fmt;\n      }\n      args.map($str).forEach((variable, index) => {\n        const template = `{${index}}`;\n        while (fmt.includes(template)) {\n          fmt = fmt.replace(template, variable);\n        }\n      });\n\n      return fmt;\n    };\n\n    const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n      return $bool(condition) ? ifTrue : ifFalse;\n    };\n\n    const $int = (x: any): number => parseInt(x);\n    const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n      const xType = $type(x);\n      return types.map($str).some((t) => xType === t);\n    };\n\n    const $tisstring = (x: any) => {\n      return $isinstance(x, \"string\");\n    };\n    const $tisnumber = (x: any) => {\n      return $isinstance(x, \"number\", \"bigint\");\n    };\n    const $tisundefined = (x: any) => {\n      return $isinstance(x, \"undefined\");\n    };\n    const $tisobject = (x: any) => {\n      return $isinstance(x, \"object\");\n    };\n    const $tisboolean = (x: any) => {\n      return $isinstance(x, \"boolean\");\n    };\n    const $isnil = (x: any) => {\n      return x === null || x === undefined;\n    };\n\n    const $endsWith = (x: any, searchString: string, endPos?: number) => {\n      x = $str(x);\n      searchString = $str(searchString);\n      return x.endsWith(searchString, endPos);\n    };\n    const $startsWith = (x: any, searchString: string, pos?: number) => {\n      return $str(x).startsWith(searchString, pos);\n    };\n    const $lower = (x: any) => {\n      return $str(x).toLowerCase();\n\n    };\n    const $upper = (x: any) => {\n      return $str(x).toUpperCase();\n    };\n\n    const $len = (x: any): number => {\n      return $str(x).length;\n    };\n\n    const $max = (...args: any[]): any => {\n      return Math.max(\n        ...args\n          .map($str)\n          .map($float)\n          .filter((x) => !isNaN(x))\n      );\n    };\n    const $min = (...args: any[]): any => {\n      return Math.min(\n        ...args\n          .map($str)\n          .map($float)\n          .filter((x) => !isNaN(x))\n      );\n    };\n\n    const $pow = (a: number, b: number) => Math.pow(a, b);\n    const $round = (a: number) => Math.round(a);\n    const $math = (key: string, ...args: any[]) => {\n      try {\n        const intrinsic = (Math as any)[key];\n        const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n        if (result) {\n          return result;\n        }\n      } catch (error: any) {\n        this.logs.push({\n          level: \"ERROR\",\n          error,\n          message: error.message || `${error}`,\n          lineNumber: NaN,\n          timestamp: new Date(),\n        });\n      }\n\n      const argv = args.join(\", \");\n      this.logs.push({\n        level: \"WARN\",\n        lineNumber: NaN,\n        message: `Couldn't resolve Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`,\n        timestamp: new Date(),\n      });\n      return `$math('${key}'${!argv ? \"\" : \", \" + argv})`;\n    };\n    const $concat = (...args: any[]) => {\n      return args.map($str).join(\"\");\n    };\n    const $substring = (x: string, start: number, end?: number) => {\n      const str = $str(x);\n      if (start === undefined || !check.isNumber(start) || start < 0) {\n        start = 0;\n      }\n      if (end === undefined || !check.isNumber(start) || end > str.length) {\n        end = str.length;\n      }\n      return str.substring(start, end);\n\n    };\n    const $type = (x: any) => typeof x;\n    const $getattr = (obj: any, ...path: string[]) => {\n      let ptr = obj;\n      path.filter(check.isString).forEach((literalKey) => {\n        // Split key into parts on '.'\n        let keys = literalKey.split(\".\");\n\n        // Check if first attr exists if not revert back\n        // to original key\n        if (!ptr[keys[0]]) {\n          keys = [literalKey];\n        }\n\n        keys\n          .filter((x) => !!x)\n          .forEach((key) => {\n            if (ptr && key && ptr[key]) {\n              ptr = ptr[key];\n            }\n          });\n      });\n\n\n      return ptr;\n    };\n\n    const $hasattr = (obj: any, ...path: string[]) => {\n      let ptr = obj;\n      let result = true;\n      path.filter(check.isString).forEach((literalKey) => {\n        // Split key into parts on '.'\n        let keys = literalKey.split(\".\");\n\n        // Check if first attr exists if not revert back\n        // to original key\n        if (!ptr[keys[0]]) {\n          keys = [literalKey];\n        }\n\n        keys\n          .filter((x) => !!x)\n          .forEach((key) => {\n            if (ptr && key && ptr[key]) {\n              ptr = ptr[key];\n            } else {\n              result = false;\n            }\n          });\n      });\n\n\n      return result;\n    };\n    const $isset = (obj: any) => {\n      return !$str(obj).startsWith(\"$\");\n    };\n\n    const $includes = (x: any, value: any) => {\n      if (x) {\n        if (x.includes && check.isFunction(x.includes)) {\n          return x.includes(value);\n        }\n\n        if (x.has && check.isFunction(x.has)) {\n          return x.has(value);\n        }\n      }\n\n      return false;\n    };\n\n    const $now = () => {\n      return new Date();\n    };\n\n    return {\n      $if,\n      $abs,\n      $all,\n      $any,\n      $bool,\n      $float,\n      $str,\n      $format,\n      $int,\n      $isnil,\n      $isinstance,\n      $tisstring,\n      $tisnumber,\n      $tisboolean,\n      $tisundefined,\n      $tisobject,\n      $len,\n      $max,\n      $min,\n      $pow,\n      $round,\n      $substring,\n      $type,\n      $math,\n      $getattr,\n      $concat,\n      $hasattr,\n      $isset,\n      $includes,\n      $endsWith,\n      $startsWith,\n      $lower,\n      $upper,\n      $now,\n    };\n  }\n\n  fixName(name: string) {\n    return name.startsWith(\"$\") ? name : \"$\" + name;\n  }\n\n  fnExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.funcs || {});\n  }\n\n  varExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.vars || {});\n  }\n\n  addVar(name: string, value: any) {\n    name = this.fixName(name);\n    this.ctx.vars = this.ctx.vars || {};\n    this.ctx.vars[name] = value;\n  }\n\n  addFunction(name: string, cb: AnyFn) {\n    name = this.fixName(name);\n    this.ctx.funcs = this.ctx.funcs || {};\n    this.ctx.funcs[name] = cb;\n  }\n\n  clearLogs() {\n    this.logs = [];\n  }\n\n  parse(sentence: string): ParseTemplateResult {\n    const result = parseTemplate(sentence, this.ctx || {});\n    this.logs.push(...result.logs);\n    return result;\n  }\n}\n\nconst _lvalParseString = <T>(str: string) => {\n  if (check.isNumeric(str)) {\n    return parseFloat(str);\n  } else if (check.isValidBoolean(str)) {\n    return check.isTrue(str);\n  } else if (date.parse(str) !== null) {\n    return new Date(str);\n  } else if (str === \"undefined\") {\n    return undefined;\n  } else if (str === \"null\") {\n    return null;\n  }\n\n  try {\n    return JSON.parse(str) as T;\n  } catch(err) {\n    return str;\n  }\n};\n\nconst lval = <T>(sentence: string, ctx?: Context) => {\n  const r = parseTemplate(sentence, ctx || {});\n  const expr = _lvalParseString<T>(r.result);\n  return {\n    result: expr,\n    logs: r.logs,\n  };\n};\n\nconst ____builtins = new TemplateParser({ includeBuiltIns: false }).builtinFunctions;\nexport type BuiltInFunction = ReturnType<typeof ____builtins>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\n\nexport default {\n  /** @deprecated change `SentenceParser` to `TemplateParser`  */\n  SentenceParser: TemplateParser,\n  TemplateParser,\n  lval,\n};\n"],
  "mappings": "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",
  "names": ["x", "value", "word", "token"]
}
