{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/date/index.ts", "../../src/check/index.ts", "../../src/eval/eval.ts", "../../src/eval/index.ts", "../../src/utils/index.ts", "../../src/inflection/index.ts", "../../src/array/sorted.ts", "../../src/array/index.ts", "../../src/fuzzy/index.ts", "../../src/@types/index.ts"],
  "sourcesContent": ["import check from \"./check\";\nimport parser from \"./eval\";\nimport inflection from \"./inflection\";\nimport date from \"./date\";\nimport array from \"./array\";\nimport fuzzy from \"./fuzzy\";\nimport utils from \"./utils\";\n\nimport * as types from \"./@types\";\n\nexport default {\n  check,\n  parser,\n  inflection,\n  utils,\n  date,\n  fuzzy,\n  array,\n  ...types,\n};\n", "const subtractSeconds = (date: Date, seconds: number) => {\n  date.setSeconds(date.getSeconds() - seconds);\n  return date;\n};\n\nconst weekend = (date: Date) => {\n  const day = date.getDay(); // get day of week as integer (0 - 6)\n  // 0 is Sunday, 6 is Saturday\n  return day === 0 || day === 6;\n};\n\nconst between = (date: Date, startDate: Date, endDate: Date) => {\n  return date >= startDate && date <= endDate;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parse(input: any): Date | null {\n  try {\n    const inputDate = new Date(input);\n    const isValidDate = !isNaN(inputDate.getTime());\n\n    if (isValidDate) {\n      return inputDate;\n    }\n  } catch (ignored) { /* empty */ }\n\n  return null;\n}\n\nexport default {\n  subtractSeconds,\n  parse,\n  weekend,\n  between,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport date from \"../date\";\n\nconst TRUE = new Boolean(true);\nconst FALSE = new Boolean(false);\nconst BOOLEANS = [true, TRUE, false, FALSE];\n\nconst isNumber = (x: any) => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n    || typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: any) => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: any) => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n    || BOOLEANS.includes(x)\n  );\n};\n\nconst isFunction = (x: any) => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: any) => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: any) => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: any) => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: any) => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\nconst isIterable = (x: any) => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: any) => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  return !isNaN(x) && !isNaN(parseFloat(x));\n};\n\nconst isValidBoolean = (x: any) => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      TRUE,\n      FALSE,\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isTrue = (x: any) => {\n  if (x && x.toString && x.toString() === \"true\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    const alts = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      TRUE,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isString(x)) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: any) => {\n  if (x && x.toString && x.toString() === \"false\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\nconst isDate = (x: any) => {\n  if (isNil(x) || !isString(x) || !isNumber(x)) {\n    return false;\n  }\n  const y = date.parse(x);\n  return y !== null;\n};\n\n// @exports\nexport default {\n  isNumber,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n  isDate,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM),\n// which is licensed under the MIT License.\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport { type AnyFn } from \"../@types\";\nimport check from \"../check\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n\n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}): any => {\n  console.assert(check.isObject(expr));\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\")) {\n        console.warn(\"WARN: Unknown variable '\" + value + \"'\");\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\")) {\n      console.warn(\"WARN: Unknown function '\" + name + \"'\");\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, Lexer, parseExpr, runExpr } from \"./eval\";\nimport { AnyFn, type TypeOf } from \"../@types\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nconst builtinFunctions = () => {\n  const $abs = (x: any): number => Math.abs(x);\n  const $all = (...args: any[]): boolean => {\n    return args.map($bool).every((x) => x === true);\n  };\n  const $any = (...args: any[]): boolean => {\n    return args.map($bool).some((x) => x === true);\n  };\n\n  const $bool = (x: any): boolean => {\n    if (check.isValidBoolean(x)) {\n      return check.isTrue(x);\n    }\n\n    return !!x && $isset(x);\n  };\n  const $float = (x: any): number => parseFloat(x);\n  const $str = (x: any): string => {\n    if (check.isObject(x)) {\n      x = JSON.stringify(x, null, 0);\n    }\n\n    if (!check.isString(x)) {\n      x = x.toString ? x.toString() : `${x}`;\n    }\n\n    return x;\n  };\n\n  const $format = (fmt: string, ...args: any[]): string => {\n    if (!check.isString(fmt) || args.length === 0) {\n      return fmt;\n    }\n    args.map($str).forEach((variable, index) => {\n      const template = `{${index}}`;\n      while (fmt.includes(template)) {\n        fmt = fmt.replace(template, variable);\n      }\n    });\n\n    return fmt;\n  };\n\n  // const $hash = (x: string): number => {\n  //   x = $str(x);\n  //   let hash = 0;\n  //   for (let i = 0; i < x.length; ++i) {\n  //     const code = x.charCodeAt(i);\n  //     hash = ((hash << 5) - hash) + code;\n  //     hash &= hash;\n  //   }\n  //   return hash;\n  // };\n\n  const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n    return $bool(condition) ? ifTrue : ifFalse;\n  };\n\n  const $int = (x: any): number => parseInt(x);\n  const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n    const xType = $type(x);\n    return types.map($str).some((t) => xType === t);\n  };\n\n  const $tisstring = (x: any) => {\n    return $isinstance(x, \"string\");\n  };\n  const $tisnumber = (x: any) => {\n    return $isinstance(x, \"number\", \"bigint\");\n  };\n  const $tisundefined = (x: any) => {\n    return $isinstance(x, \"undefined\");\n  };\n  const $tisobject = (x: any) => {\n    return $isinstance(x, \"object\");\n  };\n  const $tisboolean = (x: any) => {\n    return $isinstance(x, \"boolean\");\n  };\n  const $isnil = (x: any) => {\n    return x === null || x === undefined;\n  };\n\n  const $endsWith = (x: any, searchString: string, endPos?: number) => {\n    x = $str(x);\n    searchString = $str(searchString);\n    return x.endsWith(searchString, endPos);\n  };\n  const $startsWith = (x: any, searchString: string, pos?: number) => {\n    return $str(x).startsWith(searchString, pos);\n  };\n  const $lower = (x: any) => {\n    return $str(x).toLowerCase();\n\n  };\n  const $upper = (x: any) => {\n    return $str(x).toUpperCase();\n  };\n\n  const $len = (x: any): number => {\n    return $str(x).length;\n  };\n\n  const $max = (...args: any[]): any => {\n    return Math.max(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n  const $min = (...args: any[]): any => {\n    return Math.min(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n\n  const $pow = (a: number, b: number) => Math.pow(a, b);\n  const $round = (a: number) => Math.round(a);\n  const $math = (key: string, ...args: any[]) => {\n    try {\n      const intrinsic = (Math as any)[key];\n      const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n      if (result) {\n        return result;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    const argv = args.join(\", \");\n    return `Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`;\n  };\n  const $concat = (...args: any[]) => {\n    return args.map($str).join(\"\");\n  };\n  const $substring = (x: string, start: number, end?: number) => {\n    const str = $str(x);\n    if (start === undefined || !check.isNumber(start) || start < 0) {\n      start = 0;\n    }\n    if (end === undefined || !check.isNumber(start) || end > str.length) {\n      end = str.length;\n    }\n    return str.substring(start, end);\n\n  };\n  const $type = (x: any) => typeof x;\n  const $getattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          }\n        });\n    });\n\n\n    return ptr;\n  };\n\n  const $hasattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    let result = true;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          } else {\n            result = false;\n          }\n        });\n    });\n\n\n    return result;\n  };\n  const $isset = (obj: any) => {\n    return !$str(obj).startsWith(\"$\");\n  };\n\n  const $includes = (x: any, value: any) => {\n    if (x) {\n      if (x.includes && check.isFunction(x.includes)) {\n        return x.includes(value);\n      }\n\n      if (x.has && check.isFunction(x.has)) {\n        return x.has(value);\n      }\n    }\n\n    return false;\n  };\n\n  const $now = () => {\n    return new Date();\n  };\n\n  return {\n    $if,\n    $abs,\n    $all,\n    $any,\n    $bool,\n    $float,\n    $str,\n    $format,\n    $int,\n    $isnil,\n    $isinstance,\n    $tisstring,\n    $tisnumber,\n    $tisboolean,\n    $tisundefined,\n    $tisobject,\n    $len,\n    $max,\n    $min,\n    $pow,\n    $round,\n    $substring,\n    $type,\n    $math,\n    $getattr,\n    $concat,\n    $hasattr,\n    $isset,\n    $includes,\n    $endsWith,\n    $startsWith,\n    $lower,\n    $upper,\n    $now,\n  };\n};\n\n/**\n *\n * @param sentence sentence\n * @param _ctx context\n * @returns evaludated sentence\n *\n * @deprecated use `class SentenceParser`\n */\nconst parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  return sentence\n    .split(\"\\n\")\n    .map((line) => _parseSentence(line , _ctx))\n    .join(\"\\n\");\n};\n\nconst _parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      while (word && (isPeriod || isExcla)) {\n        word = word.substring(0, word.length - 1);\n\n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }\n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n\n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && lex.nextToken() !== \"!\") {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return builder.join(\"\").trim();\n};\n\nexport type BuiltInFunction = ReturnType<typeof builtinFunctions>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\nexport type Context = EvalContext;\nexport type SentenceParserOptions = {\n  includeBuiltIns: boolean,\n};\nclass SentenceParser {\n  constructor(\n    private options: SentenceParserOptions = {\n      includeBuiltIns: true,\n    },\n    private ctx: Context = {},\n  ) {\n\n    if (options.includeBuiltIns) {\n      this.ctx.funcs = {\n        ...builtinFunctions(),\n        ...(this.ctx.funcs || {}),\n      };\n    }\n\n  }\n\n  fixName(name: string) {\n    return name.startsWith(\"$\") ? name : \"$\" + name;\n  }\n\n  addVar(name: string, value: any) {\n    name = this.fixName(name);\n    this.ctx.vars = this.ctx.vars || {};\n    this.ctx.vars[name] = value;\n  }\n\n  addFunction(name: string, cb: AnyFn) {\n    name = this.fixName(name);\n    this.ctx.funcs = this.ctx.funcs || {};\n    this.ctx.funcs[name] = cb;\n  }\n\n  parse(sentence: string) {\n    return parseSentence(sentence, this.ctx || {});\n  }\n\n}\n\nexport default {\n  SentenceParser,\n  builtinFunctions,\n  parseSentence,\n};\n", "import check from \"../check\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst hashCode = (str: any, coerceToString=true): number | null => {\n\n  if (coerceToString) {\n    if (!check.isString(str)) {\n      if (check.isSet(str)) {\n        str = Array.from(str);\n      }\n\n      if (check.isObject(str)) {\n        try {\n          str = JSON.stringify(str);\n          // eslint-disable-next-line no-empty\n        } catch(ignored) {}\n      }\n\n      if (!check.isString(str) && str.toString) {\n        str = str.toString();\n      }\n    }\n  }\n\n  if (!check.isString(str)) {\n    return null;\n  }\n\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nconst capitalize = (str: string) => {\n  if (!check.isString(str)) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport default {\n  hashCode,\n  capitalize,\n};", "\n// This code is a port of (i.e., based on) the inflection project (https://github.com/jpvanhal/inflection),\n// which is licensed under the MIT License.\n// Copyright (C) 2012-2020 Janne Vanhala\n\nimport utils from \"../utils\";\n\n\nexport type RegexReplaceList = [RegExp, string][]\n\nconst PLURALS: RegexReplaceList = [\n  [/(quiz)$/i, \"$1zes\"],\n  [/^(oxen)$/i, \"$1\"],\n  [/^(ox)$/i, \"$1en\"],\n  [/(m|l)ice$/i, \"$1ice\"],\n  [/(m|l)ouse$/i, \"$1ice\"],\n  [/(passer)s?by$/i, \"$1sby\"],\n  [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n  [/(x|ch|ss|sh)$/i, \"$1es\"],\n  [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n  [/(hive)$/i, \"$1s\"],\n  [/([lr])f$/i, \"$1ves\"],\n  [/([^f])fe$/i, \"$1ves\"],\n  [/sis$/i, \"ses\"],\n  [/([ti])a$/i, \"$1a\"],\n  [/([ti])um$/i, \"$1a\"],\n  [/(buffal|potat|tomat)o$/i, \"$1oes\"],\n  [/(bu)s$/i, \"$1ses\"],\n  [/(alias|status)$/i, \"$1es\"],\n  [/(octop|vir)i$/i, \"$1i\"],\n  [/(octop|vir)us$/i, \"$1i\"],\n  [/^(ax|test)is$/i, \"$1es\"],\n  [/s$/i, \"s\"],\n  [/$/i, \"s\"],\n];\n\nconst SINGULARS: RegexReplaceList = [\n  [/(database)s$/i, \"$1\"],\n  [/(quiz)zes$/i, \"$1\"],\n  [/(matr)ices$/i, \"$1ix\"],\n  [/(vert|ind)ices$/i, \"$1ex\"],\n  [/(passer)sby$/i, \"$1by\"],\n  [/^(ox)en/i, \"$1\"],\n  [/(alias|status)(es)?$/i, \"$1\"],\n  [/(octop|vir)(us|i)$/i, \"$1us\"],\n  [/^(a)x[ie]s$/i, \"$1xis\"],\n  [/(cris|test)(is|es)$/i, \"$1is\"],\n  [/(shoe)s$/i, \"$1\"],\n  [/(o)es$/i, \"$1\"],\n  [/(bus)(es)?$/i, \"$1\"],\n  [/(m|l)ice$/i, \"$1ouse\"],\n  [/(x|ch|ss|sh)es$/i, \"$1\"],\n  [/(m)ovies$/i, \"$1ovie\"],\n  [/(s)eries$/i, \"$1eries\"],\n  [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n  [/([lr])ves$/i, \"$1f\"],\n  [/(tive)s$/i, \"$1\"],\n  [/(hive)s$/i, \"$1\"],\n  [/([^f])ves$/i, \"$1fe\"],\n  [/(t)he(sis|ses)$/i, \"$1hesis\"],\n  [/(s)ynop(sis|ses)$/i, \"$1ynopsis\"],\n  [/(p)rogno(sis|ses)$/i, \"$1rognosis\"],\n  [/(p)arenthe(sis|ses)$/i, \"$1arenthesis\"],\n  [/(d)iagno(sis|ses)$/i, \"$1iagnosis\"],\n  [/(b)a(sis|ses)$/i, \"$1asis\"],\n  [/(a)naly(sis|ses)$/i, \"$1nalysis\"],\n  [/([ti])a$/i, \"$1um\"],\n  [/(n)ews$/i, \"$1ews\"],\n  [/(ss)$/i, \"$1\"],\n  [/s$/i, \"\"],\n];\n\nconst UNCOUNTABLES = new Set([\n  \"equipment\",\n  \"fish\",\n  \"information\",\n  \"jeans\",\n  \"money\",\n  \"rice\",\n  \"series\",\n  \"sheep\",\n  \"species\",\n]);\n\n\n/**\n\nA convenience function to add appropriate rules to plurals and singular\nfor irregular words.\n\n@param singular: irregular word in singular form\n@param plural: irregular word in plural form\n */\nconst _irregular = (singular: string, plural: string): void => {\n  const caseinsensitive = (x: string): string => {\n    return Array\n      .from(x)\n      .map((char) => \"[\" + char + char.toUpperCase() + \"]\")\n      .join(\"\");\n  };\n\n  const insert = (arr: RegexReplaceList, index: number, elem: [string, string]) => {\n    arr.splice(index, 0, [new RegExp(elem[0], \"i\"), elem[1]]);\n  };\n\n  const pluralInsert = (index: number, elem: [string, string]) => {\n    insert(PLURALS, index, elem);\n  };\n\n  const singularInsert = (index: number, elem: [string, string]) => {\n    insert(SINGULARS, index, elem);\n  };\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    pluralInsert(0, [\n      `(${singular[0]})${singular.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + singular.slice(1)\n    ]);\n  } else {\n    pluralInsert(0, [\n      `${singular[0].toUpperCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${singular[0].toLowerCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toUpperCase() + singular.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toLowerCase() + singular.slice(1)\n    ]);\n  }\n};\n\nconst camelize = (string: string, uppercaseFirstLetter = true): string => {\n  const camelCase = dasherize(string)\n    .replace(/-/, \" \")\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(word, index) {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n\n  const result = uppercaseFirstLetter\n    ? camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\n    : camelCase;\n\n  return result;\n};\n\nfunction dasherize(word: string): string {\n  // Replace underscores with dashes in the string.\n  // Example: dasherize(\"puni_puni\") returns 'puni-puni'\n  return word.replace(/_/g, \"-\");\n}\n\nfunction humanize(word: string): string {\n  /*\n    Capitalize the first word and turn underscores into spaces and strip a\n    trailing \"_id\", if any. Like titleize, this is meant for creating pretty output.\n\n    Examples:\n\n    >>> humanize(\"employee_salary\")\n    'Employee salary'\n    >>> humanize(\"author_id\")\n    'Author'\n    */\n\n  word = word.replace(/_id$/i, \"\");\n  word = word.replace(/_/g, \" \");\n  word = word.replace(/([a-z\\d]*)/g, function (m) {\n    return m.toLowerCase();\n  });\n  word = word.replace(/^\\w/, function (m) {\n    return m.toUpperCase();\n  });\n  return word;\n}\n\nfunction ordinal(number: string): string {\n  /*\n    Return the suffix that should be added to a number to denote the position\n    in an ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n    >>> ordinal(1)\n    'st'\n    >>> ordinal(2)\n    'nd'\n    >>> ordinal(1002)\n    'nd'\n    >>> ordinal(1003)\n    'rd'\n    >>> ordinal(-11)\n    'th'\n    >>> ordinal(-1021)\n    'st'\n    */\n\n  const n = Math.abs(parseInt(number));\n  if ([11, 12, 13].includes(n % 100)) {\n    return \"th\";\n  } else {\n    switch (n % 10) {\n    case 1:\n      return \"st\";\n    case 2:\n      return \"nd\";\n    case 3:\n      return \"rd\";\n    default:\n      return \"th\";\n    }\n  }\n}\n\nfunction ordinalize(number: string) {\n  /*\n    Turn a number into an ordinal string used to denote the position in an\n    ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n\n    >>> ordinalize(1)\n    '1st'\n    >>> ordinalize(2)\n    '2nd'\n    >>> ordinalize(1002)\n    '1002nd'\n    >>> ordinalize(1003)\n    '1003rd'\n    >>> ordinalize(-11)\n    '-11th'\n    >>> ordinalize(-1021)\n    '-1021st'\n    */\n\n  return number + ordinal(number);\n}\n\nconst parameterize = (string: string, separator = \"-\") => {\n  const cleaned = transliterate(string);\n  let param = cleaned.replace(/[^\\d\\w-]+/gmi, separator);\n  if (separator !== \"\") {\n    while (param.startsWith(separator)) {\n      param = param.slice(separator.length);\n    }\n\n    while (param.endsWith(separator)) {\n      param = param.slice(0, param.length - separator.length);\n    }\n  }\n  return param.toLowerCase();\n};\n\nconst pluralize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  const endsWithLetter = /[A-Za-z]$/.test(word);\n  if (!word || UNCOUNTABLES.has(word.toLowerCase()) || !endsWithLetter) {\n    return word;\n  }\n\n  for (const elem of PLURALS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n\n  return word;\n};\n\nconst singularize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  for (const u of UNCOUNTABLES) {\n    const regex = new RegExp(`\\\\b${u}\\\\b`, \"i\");\n    if (regex.test(word)) {\n      return word;\n    }\n  }\n\n  for (const elem of SINGULARS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n  return word;\n};\n\nconst tableize = (word: string): string => {\n  return pluralize(underscore(word));\n};\n\nfunction titleize(word: string) {\n  return humanize(underscore(word))\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n}\n\n\nfunction transliterate(string: string) {\n  const normalized = string.normalize(\"NFKD\");\n  return normalized\n    .replace(/[\\u0300-\\u036f]/g, \"\") // remove combining diacritical marks\n    // eslint-disable-next-line no-control-regex\n    .replace(/[^\\x00-\\x7F]/g, \"\") // remove non-ASCII characters\n    .trim();\n}\n\nfunction underscore(word: string) {\n  let underscored = word.replace(/([a-z\\d])([A-Z])/g, \"$1_$2\"); // split camelCase\n  underscored = underscored.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\"); // split PascalCase\n  underscored = underscored.replace(/-/g, \"_\"); // replace hyphens with underscores\n  return underscored.toLowerCase();\n}\n\n\n\n_irregular(\"person\", \"people\");\n_irregular(\"man\", \"men\");\n_irregular(\"human\", \"humans\");\n_irregular(\"child\", \"children\");\n_irregular(\"sex\", \"sexes\");\n_irregular(\"move\", \"moves\");\n_irregular(\"cow\", \"kine\");\n_irregular(\"zombie\", \"zombies\");\n\nexport default {\n  camelize,\n  dasherize,\n  humanize,\n  ordinal,\n  ordinalize,\n  parameterize,\n  pluralize,\n  singularize,\n  tableize,\n  titleize,\n  transliterate,\n  underscore,\n\n  UNCOUNTABLES,\n  PLURALS,\n  SINGULARS,\n};", "import check from \"../check\";\n\nexport type BisectArrayOptions<T> = {\n    key: (a: T) => number,\n    cmp?: (a: T, b: T) => number,\n    asReversed: boolean,\n    items: T[]\n};\n\nexport class BisectArray<TData> extends Array<TData> {\n  constructor(private opts: BisectArrayOptions<TData>) {\n    const items = opts.items;\n    super(...items);\n    if (this.isValidCmp()) {\n      this.sort(this.opts.cmp);\n    } else {\n      this.sort((a, b) => this.opts.key(a) - this.opts.key(b));\n    }\n\n    if (this.opts.asReversed) {\n      this.reverse();\n    }\n  }\n\n  pop(): TData | undefined {\n    return this.isReversed() ? super.pop() : super.shift();\n  }\n\n  push(...items: TData[]): number {\n    for (const item of items) {\n      const index = this.binarySearch(item);\n      this.splice(index, 0, item);\n    }\n    return this.length;\n  }\n\n  private binarySearch(item: TData): number {\n    let left = 0;\n    let right = this.length - 1;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.shouldSwap(this[mid], item)) {\n        left = mid + 1;\n      } else if (this.shouldSwap(item, this[mid])) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return left;\n  }\n\n  private shouldSwap(a: TData, b: TData): boolean {\n    if (this.opts.cmp && this.isValidCmp()) {\n      return this.isReversed() ?  this.opts.cmp(b, a) <= 0 : this.opts.cmp(a, b) <= 0;\n    }\n    const keyA = this.opts.key(a);\n    const keyB = this.opts.key(b);\n    return (this.isReversed() ? keyB - keyA <= 0 : keyA - keyB <= 0);\n  }\n\n  isValidCmp() {\n    return this.opts.cmp && check.isFunction(this.opts.cmp);\n  }\n\n  public isReversed() {\n    return this.opts.asReversed;\n  }\n}\n\nexport class ReverseSortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: true, items});\n  }\n}\n\nexport class SortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: false, items});\n  }\n}\n\nexport class ReverseNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: true, items});\n  }\n}\n\nexport class SortedNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: false, items});\n  }\n}\n\nexport class ReverseStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class SortedStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class ReverseCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}\n\nexport class SortedCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}", "import * as sorted from \"./sorted\";\n\nexport default {\n  ...sorted,\n};", "import { ReverseSortedArray } from \"../array/sorted\";\n\n\n/**\n * Compares the similarity between two strings using an n-gram comparison method.\n * The grams default to length 2.\n * @param str1 The first string to compare.\n * @param str2 The second string to compare.\n * @param gramSize The size of the grams. Defaults to length 2.\n */\nconst similarity = (str1: string, str2: string, gramSize = 2) => {\n  const getNGrams = (s: string, len: number) => {\n    s = \" \".repeat(len - 1) + s.toLowerCase() + \" \".repeat(len - 1);\n    const v = new Array(s.length - len + 1);\n    for (let i = 0; i < v.length; i++) {\n      v[i] = s.slice(i, i + len);\n    }\n    return v;\n  };\n\n  if (!str1?.length || !str2?.length) { return 0.0; }\n\n  // Order the strings by length so the order they're passed in doesn't matter\n  // and so the smaller string's ngrams are always the ones in the set\n  const s1 = str1.length < str2.length ? str1 : str2;\n  const s2 = str1.length < str2.length ? str2 : str1;\n\n  const pairs1 = getNGrams(s1, gramSize);\n  const pairs2 = getNGrams(s2, gramSize);\n  const set = new Set<string>(pairs1);\n\n  const total = pairs2.length;\n  let hits = 0;\n  for (const item of pairs2) {\n    if (set.delete(item)) {\n      hits++;\n    }\n  }\n  return hits / total;\n};\n\n/**\n *\n * Sorts an array in place based on similarity. This method mutates the array and returns a reference to the same array.\n * @param value string that will be used to compare similarity\n * @param topK return top k matches\n * @param gramSize The size of the grams. Defaults to length 2.\n * @param values array to sort\n * @param key Function used to get the value to sort by\n * @returns a reference to the same array which was sorted in place.\n */\nconst topSimilar = <T = string>(value: T, values: T[], key: (obj: T) => string, topK = 5, gramSize = 2) => {\n  const str1 = key(value);\n  if (topK <= 0) {\n    topK = 5;\n  }\n\n  const arr = new ReverseSortedArray((x: T) => similarity(str1, key(x), gramSize));\n  values.forEach((x) => {\n    arr.push(x);\n\n    if (arr.length > topK) {\n      arr.pop();\n    }\n  });\n\n  return [...arr];\n};\n\nexport default {\n  similarity,\n  topSimilar,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\n"],
  "mappings": "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",
  "names": ["x", "token", "word"]
}
