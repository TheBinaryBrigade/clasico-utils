{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/@types/index.ts", "../../src/array/sorted.ts", "../../src/date/index.ts", "../../src/check/index.ts", "../../src/array/index.ts", "../../src/diff/index.ts", "../../src/fuzzy/index.ts", "../../src/utils/index.ts", "../../src/inflection/index.ts", "../../src/template/eval.ts", "../../src/template/index.ts"],
  "sourcesContent": ["import * as types from \"./@types\";\nimport array from \"./array\";\nimport check from \"./check\";\nimport date from \"./date\";\nimport diff from \"./diff\";\nimport parser from \"./template\";\nimport fuzzy from \"./fuzzy\";\nimport inflection from \"./inflection\";\nimport utils from \"./utils\";\n\nexport default {\n  check,\n  /**\n   * @deprecated change `parser` to `template`\n   */\n  parser,\n  template: parser,\n  inflection,\n  utils,\n  date,\n  fuzzy,\n  array,\n  diff,\n  ...types,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\n", "import check from \"../check\";\n\nexport type BisectArrayOptions<T> = {\n    key: (a: T) => number,\n    cmp?: (a: T, b: T) => number,\n    asReversed: boolean,\n    items: T[]\n};\n\nexport class BisectArray<TData> extends Array<TData> {\n  constructor(private opts: BisectArrayOptions<TData>) {\n    const items = opts.items;\n    super(...items);\n    if (this.isValidCmp()) {\n      this.sort(this.opts.cmp);\n    } else {\n      this.sort((a, b) => this.opts.key(a) - this.opts.key(b));\n    }\n\n    if (this.opts.asReversed) {\n      this.reverse();\n    }\n  }\n\n  pop(): TData | undefined {\n    return this.isReversed() ? super.pop() : super.shift();\n  }\n\n  push(...items: TData[]): number {\n    for (const item of items) {\n      const index = this.binarySearch(item);\n      this.splice(index, 0, item);\n    }\n    return this.length;\n  }\n\n  private binarySearch(item: TData): number {\n    let left = 0;\n    let right = this.length - 1;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.shouldSwap(this[mid], item)) {\n        left = mid + 1;\n      } else if (this.shouldSwap(item, this[mid])) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return left;\n  }\n\n  private shouldSwap(a: TData, b: TData): boolean {\n    if (this.opts.cmp && this.isValidCmp()) {\n      return this.isReversed() ?  this.opts.cmp(b, a) <= 0 : this.opts.cmp(a, b) <= 0;\n    }\n    const keyA = this.opts.key(a);\n    const keyB = this.opts.key(b);\n    return (this.isReversed() ? keyB - keyA <= 0 : keyA - keyB <= 0);\n  }\n\n  isValidCmp() {\n    return this.opts.cmp && check.isFunction(this.opts.cmp);\n  }\n\n  public isReversed() {\n    return this.opts.asReversed;\n  }\n}\n\nexport class ReverseSortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: true, items});\n  }\n}\n\nexport class SortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: false, items});\n  }\n}\n\nexport class ReverseNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: true, items});\n  }\n}\n\nexport class SortedNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: false, items});\n  }\n}\n\nexport class ReverseStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class SortedStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class ReverseCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}\n\nexport class SortedCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}", "// const subtractSeconds = (date: Date, seconds: number) => {\n//   date.setSeconds(date.getSeconds() - seconds);\n//   return date;\n// };\n\nconst isWeekend = (date: Date) => {\n  const day = date.getDay(); // get day of week as integer (0 - 6)\n  // 0 is Sunday, 6 is Saturday\n  return day === 0 || day === 6;\n};\n\nconst between = (date: Date, startDate: Date, endDate: Date) => {\n  return date >= startDate && date <= endDate;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst parse = (input: any): Date | null => {\n  const inputDate = new Date(input);\n  const isValidDate = !isNaN(inputDate.getTime());\n\n  if (isValidDate) {\n    return inputDate;\n  }\n\n  return null;\n};\n\nexport type TimeUnit =\n  \"years\"\n  | \"year\"\n  | \"months\"\n  | \"month\"\n  | \"days\"\n  | \"day\"\n  | \"hours\"\n  | \"hour\"\n  | \"minutes\"\n  | \"minute\"\n  | \"seconds\"\n  | \"second\";\n\nconst timeSince = (date: Date): [number, TimeUnit] => {\n  const seconds = Math.floor((+new Date() - +date) / 1000);\n  let interval = seconds / 31536000;\n\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"year\" : \"years\"];\n  }\n  interval = seconds / 2592000;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"month\" : \"months\"];\n  }\n\n  interval = seconds / 86400;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"day\" : \"days\"];\n  }\n\n  interval = seconds / 3600;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"hour\" : \"hours\"];\n  }\n\n  interval = seconds / 60;\n  if (interval > 1) {\n    interval = Math.floor(interval);\n    return [interval, interval === 1 ? \"minute\" : \"minutes\"];\n  }\n\n  interval = Math.floor(seconds);\n  return [interval, interval === 1 ? \"second\" : \"seconds\"];\n};\n\nexport default {\n  // subtractSeconds,\n  parse,\n  isWeekend,\n  between,\n  timeSince,\n};", "\nimport date from \"../date\";\n\nconst isNumber = (x: unknown): x is number => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n  );\n};\n\nconst isBigInt = (x: unknown): x is bigint => {\n  return (\n    typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: unknown): x is string => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: unknown): x is boolean => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n  );\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst isFunction = (x: unknown): x is Function => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: unknown): x is object => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: unknown): x is null | undefined => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: unknown): x is unknown[] => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: unknown): x is Set<unknown> => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIterable = (x: any): x is Iterable<unknown> => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: unknown): boolean => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return !isNaN(x as any) && !isNaN(parseFloat(x));\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isValidBoolean = (x: any): boolean => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      new Boolean(true),\n      new Boolean(false),\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst valueOf = <T>(x: T): string | number | bigint | boolean | symbol | T => {\n  if (\n    x instanceof Boolean\n    || x instanceof Number\n    || x instanceof String\n    || x instanceof BigInt\n    || x instanceof Symbol\n  ) {\n    if (x.valueOf && isFunction(x.valueOf)) {\n      return x.valueOf();\n    }\n  }\n\n  return x;\n};\n\nconst isTrue = (x: unknown): boolean => {\n  const valueOfX = valueOf(x);\n  if (x === true || valueOfX === true) {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const alts: any[] = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      new Boolean(true),\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (!isNil(valueOfX)) {\n      if (alts.includes(valueOfX)) {\n        return true;\n      }\n\n      if (isString(valueOfX)) {\n        x = valueOfX;\n      }\n    }\n\n    if (isString(x)) {\n      const y = (x as string).trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (y.length <= len && alts.includes(y.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: unknown): boolean => {\n  if (x === false || valueOf(x) === false) {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\nconst isDate = (x: unknown): boolean => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (isString(x) && typeof x === \"string\") {\n    x = x.trim();\n\n    if (!x) {\n      return false;\n    }\n  }\n\n  if (isBoolean(x)) {\n    return false;\n  }\n\n  if (isArray(x) || isSet(x)) {\n    return false;\n  }\n\n  const y = date.parse(x);\n  return !!y;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isError = (x: any, errorLike = false): x is Error => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (x instanceof Error) {\n    return true;\n  }\n\n  if (errorLike && x && x.stack && x.message) {\n    return true;\n  }\n\n  return false;\n};\n\n// @exports\nexport default {\n  isNil,\n  isNumber,\n  isBigInt,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n  isDate,\n  isError,\n};\n", "import * as sorted from \"./sorted\";\n\nexport default {\n  ...sorted,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * program: \"patienceDiff\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiff( aLines[], bLines[], diffPlusFlag )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *      diffPlusFlag if true, returns additional arrays with the subset of lines that were\n *          either deleted or inserted.  These additional arrays are used by patienceDiffPlus.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLines[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is 0. (Only set when using patienceDiffPlus.)\n *\n */\n\nfunction patienceDiff(aLines: string[], bLines: string[], diffPlusFlag?: boolean) {\n\n  //\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n  // function is used in preparation for determining the longest common\n  // subsequence.  Specifically, it first reduces the array range in question\n  // to unique values.\n  //\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\n  // array index i as the Map value.\n  //\n\n  function findUnique(arr: string[], lo: number, hi: number) {\n\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n\n      const line = arr[i];\n\n      if (lineMap.has(line)) {\n\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n\n      } else {\n\n        lineMap.set(line, {\n          count: 1,\n          index: i\n        });\n\n      }\n\n    }\n\n    lineMap.forEach((val, key, map) => {\n\n      if (val.count !== 1) {\n\n        map.delete(key);\n\n      } else {\n\n        map.set(key, val.index);\n\n      }\n\n    });\n\n    return lineMap;\n\n  }\n\n  //\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n  // down the aArray and bArray ranges first, before then walking the comparison\n  // between the two arrays.\n  //\n  // Returns an ordered Map, with the Map key as the common line between aArray\n  // and bArray, with the Map value as an object containing the array indexes of\n  // the matching unique lines.\n  //\n\n  function uniqueCommon(aArray: string[], aLo: number, aHi: number, bArray: string[], bLo: number, bHi: number) {\n\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key, map) => {\n\n      if (mb.has(key)) {\n\n        map.set(key, {\n          indexA: val,\n          indexB: mb.get(key)\n        });\n\n      } else {\n\n        map.delete(key);\n\n      }\n\n    });\n\n    return ma;\n\n  }\n\n    type LCSResult = {\n        line: string,\n        aIndex: number,\n        bIndex: number,\n        moved?: boolean,\n    };\n\n    //\n    // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n    // and determines the Longest Common Subsequence (LCS).\n    //\n    // Returns an ordered array of objects containing the array indexes of the\n    // matching lines for a LCS.\n    //\n\n    function longestCommonSubsequence(abMap: Map<string, any>) {\n\n      const ja: any[] = [];\n\n      // First, walk the list creating the jagged array.\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      abMap.forEach((val, _key, _map) => {\n\n        let i = 0;\n\n        while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n\n          i++;\n\n        }\n\n        if (!ja[i]) {\n\n          ja[i] = [];\n\n        }\n\n        if (0 < i) {\n\n          val.prev = ja[i - 1][ja[i - 1].length - 1];\n\n        }\n\n        ja[i].push(val);\n\n      });\n\n      // Now, pull out the longest common subsequence.\n\n      let lcs: any[] = [];\n\n      if (0 < ja.length) {\n\n        const n = ja.length - 1;\n        lcs = [ja[n][ja[n].length - 1]];\n\n        while (lcs[lcs.length - 1].prev) {\n\n          lcs.push(lcs[lcs.length - 1].prev);\n\n        }\n\n      }\n\n      return lcs.reverse();\n\n    }\n\n    // \"result\" is the array used to accumulate the aLines that are deleted, the\n    // lines that are shared between aLines and bLines, and the bLines that were\n    // inserted.\n\n    const result: LCSResult[] = [];\n    let deleted = 0;\n    let inserted = 0;\n\n    // aMove and bMove will contain the lines that don't match, and will be returned\n    // for possible searching of lines that moved.\n\n    const aMove: string[] = [];\n    const aMoveIndex: number[] = [];\n    const bMove: string[] = [];\n    const bMoveIndex: number[] = [];\n\n    //\n    // addToResult simply pushes the latest value onto the \"result\" array.  This\n    // array captures the diff of the line, aIndex, and bIndex from the aLines\n    // and bLines array.\n    //\n\n    function addToResult(aIndex: number, bIndex: number) {\n\n      if (bIndex < 0) {\n\n        aMove.push(aLines[aIndex]);\n        aMoveIndex.push(result.length);\n        deleted++;\n\n      } else if (aIndex < 0) {\n\n        bMove.push(bLines[bIndex]);\n        bMoveIndex.push(result.length);\n        inserted++;\n\n      }\n\n      result.push({\n        line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n        aIndex,\n        bIndex,\n      });\n\n    }\n\n    //\n    // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n    // this function might recursively call recurseLCS to further match the lines\n    // between aLines and bLines.\n    //\n\n    function addSubMatch(aLo: number, aHi: number, bLo: number, bHi: number) {\n\n      // Match any lines at the beginning of aLines and bLines.\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n\n        addToResult(aLo++, bLo++);\n\n      }\n\n      // Match any lines at the end of aLines and bLines, but don't place them\n      // in the \"result\" array just yet, as the lines between these matches at\n      // the beginning and the end need to be analyzed first.\n\n      const aHiTemp = aHi;\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n\n        aHi--;\n        bHi--;\n\n      }\n\n      // Now, check to determine with the remaining lines in the subsequence\n      // whether there are any unique common lines between aLines and bLines.\n      //\n      // If not, add the subsequence to the result (all aLines having been\n      // deleted, and all bLines having been inserted).\n      //\n      // If there are unique common lines between aLines and bLines, then let's\n      // recursively perform the patience diff on the subsequence.\n\n      const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n      if (uniqueCommonMap.size === 0) {\n\n        while (aLo <= aHi) {\n\n          addToResult(aLo++, - 1);\n\n        }\n\n        while (bLo <= bHi) {\n\n          addToResult(- 1, bLo++);\n\n        }\n\n      } else {\n\n        recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n\n      }\n\n      // Finally, let's add the matches at the end to the result.\n\n      while (aHi < aHiTemp) {\n\n        addToResult(++aHi, ++bHi);\n\n      }\n\n    }\n\n    //\n    // recurseLCS finds the longest common subsequence (LCS) between the arrays\n    // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n    // recursively performs another LCS search (via addSubMatch), until there are\n    // none found, at which point the subsequence is dumped to the result.\n    //\n\n    function recurseLCS(aLo: number, aHi: number, bLo: number, bHi: number, uniqueCommonMap?: Map<string, any>) {\n\n      const x = longestCommonSubsequence(uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi));\n\n      if (x.length === 0) {\n\n        addSubMatch(aLo, aHi, bLo, bHi);\n\n      } else {\n\n        if (aLo < x[0].indexA || bLo < x[0].indexB) {\n\n          addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n\n        }\n\n        let i;\n        for (i = 0; i < x.length - 1; i++) {\n\n          addSubMatch(x[i].indexA, x[i + 1].indexA - 1, x[i].indexB, x[i + 1].indexB - 1);\n\n        }\n\n        if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n\n          addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n\n        }\n\n      }\n\n    }\n\n    recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n    if (diffPlusFlag) {\n\n      return {\n        lines: result,\n        lineCountDeleted: deleted,\n        lineCountInserted: inserted,\n        lineCountMoved: 0,\n        aMove,\n        aMoveIndex,\n        bMove,\n        bMoveIndex,\n      };\n\n    }\n\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n    };\n\n}\n\n/**\n * program: \"patienceDiffPlus\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiffPlus( aLines[], bLines[] )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLine[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *          moved is true if the line was moved from elsewhere in aLines[] or bLines[].\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is the number of lines that moved.\n *\n */\n\n// function patienceDiffPlus(aLines: string[], bLines: string[]) {\n\n//   const difference = patienceDiff(aLines, bLines, true);\n\n//   let aMoveNext = difference.aMove || [];\n//   let aMoveIndexNext = difference.aMoveIndex || [];\n//   let bMoveNext = difference.bMove || [];\n//   let bMoveIndexNext = difference.bMoveIndex || [];\n\n//   delete difference.aMove;\n//   delete difference.aMoveIndex;\n//   delete difference.bMove;\n//   delete difference.bMoveIndex;\n\n//   let lastLineCountMoved;\n\n//   do {\n\n//     const aMove = aMoveNext;\n//     const aMoveIndex = aMoveIndexNext;\n//     const bMove = bMoveNext;\n//     const bMoveIndex = bMoveIndexNext;\n\n//     aMoveNext = [];\n//     aMoveIndexNext = [];\n//     bMoveNext = [];\n//     bMoveIndexNext = [];\n\n//     const subDiff = patienceDiff(aMove, bMove, false);\n\n//     lastLineCountMoved = difference.lineCountMoved;\n\n//     subDiff.lines.forEach((v, i) => {\n\n//       if (0 <= v.aIndex && 0 <= v.bIndex) {\n\n//         difference.lines[aMoveIndex[v.aIndex]].moved = true;\n//         difference.lines[bMoveIndex[v.bIndex]].aIndex = aMoveIndex[v.aIndex];\n//         difference.lines[bMoveIndex[v.bIndex]].moved = true;\n//         difference.lineCountInserted--;\n//         difference.lineCountDeleted--;\n//         difference.lineCountMoved++;\n\n//       } else if (v.bIndex < 0) {\n\n//         aMoveNext.push(aMove[v.aIndex]);\n//         aMoveIndexNext.push(aMoveIndex[v.aIndex]);\n\n//       } else {\n\n//         bMoveNext.push(bMove[v.bIndex]);\n//         bMoveIndexNext.push(bMoveIndex[v.bIndex]);\n\n//       }\n\n//     });\n\n//   } while (0 < difference.lineCountMoved - lastLineCountMoved);\n\n//   return difference;\n\n// }\n\nconst ___IGNORE = patienceDiff([], [], true);\nexport type PatienceDiffResult = typeof ___IGNORE;\n\nexport type ChangeType = \"deleted\" | \"inserted\" | \"changed\" | \"unknown\";\n\nexport type Change = {\n    lineNumber: number,\n    changeType: ChangeType,\n    lineContent: string,\n    aIndex: number,\n    bIndex: number,\n};\n\nexport type DiffResult = {\n    changes: Change[],\n    deletedCount: number,\n    insertedCount: number,\n    movedCount: number,\n    linedMovedFromA: string[],\n    linesMovedFromB: string[],\n    _diff: PatienceDiffResult,\n};\n\nconst compare = (a: string, b: string): DiffResult => {\n  const desc = patienceDiff(a.split(\"\\n\"), b.split(\"\\n\"), true);\n\n  const changes: Change[] = desc.lines.map((line, index) => {\n    let changeType: ChangeType = \"unknown\";\n    if (line.aIndex >= 0 && line.bIndex < 0) {\n      changeType = \"deleted\";\n    } else if (line.aIndex < 0 && line.bIndex >= 0) {\n      changeType = \"inserted\";\n    } else if (line.aIndex >= 0 && line.bIndex >= 0) {\n      changeType = \"changed\";\n    }\n\n    return {\n      changeType,\n      lineNumber: index + 1,\n      lineContent: line.line,\n      aIndex: line.aIndex,\n      bIndex: line.bIndex,\n    };\n  });\n\n  return {\n    changes,\n    deletedCount: desc.lineCountDeleted,\n    insertedCount: desc.lineCountInserted,\n    movedCount: desc.lineCountInserted,\n    linedMovedFromA: desc.aMove || [],\n    linesMovedFromB: desc.bMove || [],\n    _diff: desc,\n  };\n};\n\nexport default {\n  compare,\n};", "import { ReverseSortedArray } from \"../array/sorted\";\n\n\n/**\n * Compares the similarity between two strings using an n-gram comparison method.\n * The grams default to length 2.\n * @param str1 The first string to compare.\n * @param str2 The second string to compare.\n * @param gramSize The size of the grams. Defaults to length 2.\n */\nconst similarity = (str1: string, str2: string, gramSize = 2) => {\n  const getNGrams = (s: string, len: number) => {\n    s = \" \".repeat(len - 1) + s.toLowerCase() + \" \".repeat(len - 1);\n    const v = new Array(s.length - len + 1);\n    for (let i = 0; i < v.length; i++) {\n      v[i] = s.slice(i, i + len);\n    }\n    return v;\n  };\n\n  if (!str1?.length || !str2?.length) { return 0.0; }\n\n  // Order the strings by length so the order they're passed in doesn't matter\n  // and so the smaller string's ngrams are always the ones in the set\n  const s1 = str1.length < str2.length ? str1 : str2;\n  const s2 = str1.length < str2.length ? str2 : str1;\n\n  const pairs1 = getNGrams(s1, gramSize);\n  const pairs2 = getNGrams(s2, gramSize);\n  const set = new Set<string>(pairs1);\n\n  const total = pairs2.length;\n  let hits = 0;\n  for (const item of pairs2) {\n    if (set.delete(item)) {\n      hits++;\n    }\n  }\n  return hits / total;\n};\n\n/**\n *\n * Sorts an array in place based on similarity. This method mutates the array and returns a reference to the same array.\n * @param value string that will be used to compare similarity\n * @param topK return top k matches\n * @param gramSize The size of the grams. Defaults to length 2.\n * @param values array to sort\n * @param key Function used to get the value to sort by\n * @returns a reference to the same array which was sorted in place.\n */\nconst topSimilar = <T = string>(value: T, values: T[], key: (obj: T) => string, topK = 5, thresh = 0.35, gramSize = 2) => {\n  const str1 = key(value);\n  if (topK <= 0) {\n    topK = 5;\n  }\n\n  const keysim = new Map<string, number>();\n  const arr = new ReverseSortedArray((x: T) => {\n    const value = key(x);\n    const cachedScore = keysim.get(value);\n    const score = cachedScore || similarity(str1, value, gramSize);\n    if (cachedScore === undefined) {\n      keysim.set(value, score);\n    }\n    return score;\n  });\n  values.forEach((x) => {\n    const score = similarity(str1, key(x), gramSize);\n    if (score >= thresh) {\n      arr.push(x);\n\n      if (arr.length > topK) {\n        const popped = arr.pop();\n\n        if (popped) {\n          keysim.delete(key(popped));\n        }\n      }\n    }\n  });\n\n  return [...arr];\n};\n\nexport default {\n  similarity,\n  topSimilar,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport check from \"../check\";\n\nconst hashCode = (str: any, coerceToString = true): number | null => {\n\n  if (coerceToString) {\n    if (!check.isString(str)) {\n      if (check.isSet(str)) {\n        str = Array.from(str);\n      }\n\n      if (check.isObject(str)) {\n        try {\n          str = JSON.stringify(str);\n        } catch (ignored) {\n          const circularReference: any[] = [];\n          const jsonString = JSON.stringify(str, (key, value) => {\n            if (typeof value === \"object\" && value !== null) {\n              if (circularReference.includes(value)) {\n                return \"[Circular]\";\n              }\n              circularReference.push(value);\n            }\n            return value;\n          });\n\n          // Replace circular references with actual object reference\n          str = jsonString.replace(/\"\\[Circular\\]\"/g, () => {\n            return JSON.stringify(\"[Circular]\");\n          });\n        }\n      }\n\n      if (!check.isString(str) && str.toString) {\n        str = str.toString();\n      }\n    }\n  }\n\n  if (!check.isString(str)) {\n    return null;\n  }\n\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nconst capitalize = (str: string) => {\n  if (!check.isString(str)) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport default {\n  hashCode,\n  capitalize,\n};", "\n// This code is a port of (i.e., based on) the inflection project (https://github.com/jpvanhal/inflection),\n// which is licensed under the MIT License.\n// Copyright (C) 2012-2020 Janne Vanhala\n\nimport utils from \"../utils\";\n\n\nexport type RegexReplaceList = [RegExp, string][]\n\nconst PLURALS: RegexReplaceList = [\n  [/(quiz)$/i, \"$1zes\"],\n  [/^(oxen)$/i, \"$1\"],\n  [/^(ox)$/i, \"$1en\"],\n  [/(m|l)ice$/i, \"$1ice\"],\n  [/(m|l)ouse$/i, \"$1ice\"],\n  [/(passer)s?by$/i, \"$1sby\"],\n  [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n  [/(x|ch|ss|sh)$/i, \"$1es\"],\n  [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n  [/(hive)$/i, \"$1s\"],\n  [/([lr])f$/i, \"$1ves\"],\n  [/([^f])fe$/i, \"$1ves\"],\n  [/sis$/i, \"ses\"],\n  [/([ti])a$/i, \"$1a\"],\n  [/([ti])um$/i, \"$1a\"],\n  [/(buffal|potat|tomat)o$/i, \"$1oes\"],\n  [/(bu)s$/i, \"$1ses\"],\n  [/(alias|status)$/i, \"$1es\"],\n  [/(octop|vir)i$/i, \"$1i\"],\n  [/(octop|vir)us$/i, \"$1i\"],\n  [/^(ax|test)is$/i, \"$1es\"],\n  [/s$/i, \"s\"],\n  [/$/i, \"s\"],\n];\n\nconst SINGULARS: RegexReplaceList = [\n  [/(database)s$/i, \"$1\"],\n  [/(quiz)zes$/i, \"$1\"],\n  [/(matr)ices$/i, \"$1ix\"],\n  [/(vert|ind)ices$/i, \"$1ex\"],\n  [/(passer)sby$/i, \"$1by\"],\n  [/^(ox)en/i, \"$1\"],\n  [/(alias|status)(es)?$/i, \"$1\"],\n  [/(octop|vir)(us|i)$/i, \"$1us\"],\n  [/^(a)x[ie]s$/i, \"$1xis\"],\n  [/(cris|test)(is|es)$/i, \"$1is\"],\n  [/(shoe)s$/i, \"$1\"],\n  [/(o)es$/i, \"$1\"],\n  [/(bus)(es)?$/i, \"$1\"],\n  [/(m|l)ice$/i, \"$1ouse\"],\n  [/(x|ch|ss|sh)es$/i, \"$1\"],\n  [/(m)ovies$/i, \"$1ovie\"],\n  [/(s)eries$/i, \"$1eries\"],\n  [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n  [/([lr])ves$/i, \"$1f\"],\n  [/(tive)s$/i, \"$1\"],\n  [/(hive)s$/i, \"$1\"],\n  [/([^f])ves$/i, \"$1fe\"],\n  [/(t)he(sis|ses)$/i, \"$1hesis\"],\n  [/(s)ynop(sis|ses)$/i, \"$1ynopsis\"],\n  [/(p)rogno(sis|ses)$/i, \"$1rognosis\"],\n  [/(p)arenthe(sis|ses)$/i, \"$1arenthesis\"],\n  [/(d)iagno(sis|ses)$/i, \"$1iagnosis\"],\n  [/(b)a(sis|ses)$/i, \"$1asis\"],\n  [/(a)naly(sis|ses)$/i, \"$1nalysis\"],\n  [/([ti])a$/i, \"$1um\"],\n  [/(n)ews$/i, \"$1ews\"],\n  [/(ss)$/i, \"$1\"],\n  [/s$/i, \"\"],\n];\n\nconst UNCOUNTABLES = new Set([\n  \"equipment\",\n  \"fish\",\n  \"information\",\n  \"jeans\",\n  \"money\",\n  \"rice\",\n  \"series\",\n  \"sheep\",\n  \"species\",\n]);\n\n\n/**\n\nA convenience function to add appropriate rules to plurals and singular\nfor irregular words.\n\n@param singular: irregular word in singular form\n@param plural: irregular word in plural form\n */\nconst _irregular = (singular: string, plural: string): void => {\n  const caseinsensitive = (x: string): string => {\n    return Array\n      .from(x)\n      .map((char) => \"[\" + char + char.toUpperCase() + \"]\")\n      .join(\"\");\n  };\n\n  const insert = (arr: RegexReplaceList, index: number, elem: [string, string]) => {\n    arr.splice(index, 0, [new RegExp(elem[0], \"i\"), elem[1]]);\n  };\n\n  const pluralInsert = (index: number, elem: [string, string]) => {\n    insert(PLURALS, index, elem);\n  };\n\n  const singularInsert = (index: number, elem: [string, string]) => {\n    insert(SINGULARS, index, elem);\n  };\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    pluralInsert(0, [\n      `(${singular[0]})${singular.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + singular.slice(1)\n    ]);\n  } else {\n    pluralInsert(0, [\n      `${singular[0].toUpperCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${singular[0].toLowerCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toUpperCase() + singular.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toLowerCase() + singular.slice(1)\n    ]);\n  }\n};\n\nconst camelize = (string: string, uppercaseFirstLetter = true): string => {\n  const camelCase = dasherize(string)\n    .replace(/-/, \" \")\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n\n  const result = uppercaseFirstLetter\n    ? camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\n    : camelCase;\n\n  return result;\n};\n\n/** Replace underscores with dashes in the string.\n Example: dasherize(\"puni_puni\") returns 'puni-puni'\n */\nconst dasherize = (word: string): string => {\n  return word.replace(/_/g, \"-\");\n};\n\n/**\n  Capitalize the first word and turn underscores into spaces and strip a\n  trailing \"_id\", if any. Like titleize, this is meant for creating pretty output.\n\n  Examples:\n\n  >>> humanize(\"employee_salary\")\n  'Employee salary'\n  >>> humanize(\"author_id\")\n  'Author'\n  */\nconst humanize = (word: string): string => {\n  word = word.replace(/_id$/i, \"\");\n  word = word.replace(/_/g, \" \");\n  word = word.replace(/([a-z\\d]*)/g, (m) => {\n    return m.toLowerCase();\n  });\n  word = word.replace(/^\\w/, (m) => {\n    return m.toUpperCase();\n  });\n  return word;\n};\n\n/**\n  Return the suffix that should be added to a number to denote the position\n  in an ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n  Examples:\n  >>> ordinal(1)\n  'st'\n  >>> ordinal(2)\n  'nd'\n  >>> ordinal(1002)\n  'nd'\n  >>> ordinal(1003)\n  'rd'\n  >>> ordinal(-11)\n  'th'\n  >>> ordinal(-1021)\n  'st'\n  */\nconst ordinal = (number: string | number): string => {\n  number = typeof number === \"number\" ? number : parseInt(number);\n  const n = Math.abs(number);\n  if ([11, 12, 13].includes(n % 100)) {\n    return \"th\";\n  } else {\n    switch (n % 10) {\n    case 1:\n      return \"st\";\n    case 2:\n      return \"nd\";\n    case 3:\n      return \"rd\";\n    default:\n      return \"th\";\n    }\n  }\n};\n\n/**\n  Turn a number into an ordinal string used to denote the position in an\n  ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n  Examples:\n\n  >>> ordinalize(1)\n  '1st'\n  >>> ordinalize(2)\n  '2nd'\n  >>> ordinalize(1002)\n  '1002nd'\n  >>> ordinalize(1003)\n  '1003rd'\n  >>> ordinalize(-11)\n  '-11th'\n  >>> ordinalize(-1021)\n  '-1021st'\n  */\nconst ordinalize = (number: string | number) => {\n  return number.toString() + ordinal(number);\n};\n\nconst parameterize = (string: string, separator = \"-\") => {\n  const cleaned = transliterate(string);\n  let param = cleaned.replace(/[^\\d\\w-]+/gmi, separator);\n  if (separator !== \"\") {\n    while (param.startsWith(separator)) {\n      param = param.slice(separator.length);\n    }\n\n    while (param.endsWith(separator)) {\n      param = param.slice(0, param.length - separator.length);\n    }\n  }\n  return param.toLowerCase();\n};\n\nconst pluralize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  const endsWithLetter = /[A-Za-z]$/.test(word);\n  if (!word || UNCOUNTABLES.has(word.toLowerCase()) || !endsWithLetter) {\n    return word;\n  }\n\n  for (const elem of PLURALS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n\n  return word;\n};\n\nconst singularize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  for (const u of UNCOUNTABLES) {\n    const regex = new RegExp(`\\\\b${u}\\\\b`, \"i\");\n    if (regex.test(word)) {\n      return word;\n    }\n  }\n\n  for (const elem of SINGULARS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n  return word;\n};\n\nconst tableize = (word: string): string => {\n  return pluralize(underscore(word));\n};\n\nconst titleize = (word: string) => {\n  return humanize(underscore(word))\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n};\n\n\nconst transliterate = (string: string) => {\n  const normalized = string.normalize(\"NFKD\");\n  return normalized\n    .replace(/[\\u0300-\\u036f]/g, \"\") // remove combining diacritical marks\n    // eslint-disable-next-line no-control-regex\n    .replace(/[^\\x00-\\x7F]/g, \"\") // remove non-ASCII characters\n    .trim();\n};\n\nconst underscore = (word: string) => {\n  let underscored = word.replace(/([a-z\\d])([A-Z])/g, \"$1_$2\"); // split camelCase\n  underscored = underscored.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\"); // split PascalCase\n  underscored = underscored.replace(/-/g, \"_\"); // replace hyphens with underscores\n  return underscored.toLowerCase();\n};\n\n_irregular(\"person\", \"people\");\n_irregular(\"man\", \"men\");\n_irregular(\"human\", \"humans\");\n_irregular(\"child\", \"children\");\n_irregular(\"sex\", \"sexes\");\n_irregular(\"move\", \"moves\");\n_irregular(\"cow\", \"kine\");\n_irregular(\"zombie\", \"zombies\");\n_irregular(\"slave\", \"slaves\");\n_irregular(\"this\", \"this\");\n_irregular(\"flour\", \"flour\");\n_irregular(\"milk\", \"milk\");\n_irregular(\"water\", \"water\");\n_irregular(\"reserve\", \"reserves\");\n_irregular(\"gas\", \"gasses\");\n_irregular(\"bias\", \"biases\");\n_irregular(\"atlas\", \"atlases\");\n_irregular(\"goose\", \"geese\");\n_irregular(\"pasta\", \"pastas\");\n_irregular(\"slice\", \"slices\");\n_irregular(\"cactus\", \"cacti\");\n\nexport default {\n  camelize,\n  dasherize,\n  humanize,\n  ordinal,\n  ordinalize,\n  parameterize,\n  pluralize,\n  singularize,\n  tableize,\n  titleize,\n  transliterate,\n  underscore,\n\n  UNCOUNTABLES,\n  PLURALS,\n  SINGULARS,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM),\n// which is licensed under the MIT License.\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport { type AnyFn } from \"../@types\";\nimport check from \"../check\";\nimport fuzzy from \"../fuzzy\";\nimport inflection from \"../inflection\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n\n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          // throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n          return {\n            \"kind\": \"symbol\",\n            \"payload\": {\n              \"value\": token\n            }\n          };\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport type EvalWarningMeta = {\n  timestamp: Date,\n  message: string\n};\n\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}, warnings: EvalWarningMeta[] = []): any => {\n  console.assert(check.isObject(expr));\n\n  const warnings_push = (message: string) => {\n    warnings.push({\n      timestamp: new Date(),\n      message,\n    });\n  };\n\n  const recommend = (ctxKey: keyof EvalContext, value: string): string[] => {\n    return fuzzy.topSimilar(\n      value,\n      [...Object.keys(ctx[ctxKey] || {})],\n      (x) => x,\n      5,\n    )\n      .map((str) => {\n        return str.replace(\n          /[\\u00A0-\\u9999<>&]/g,\n          (i) => \"&#\" + i.charCodeAt(0) + \";\"\n        );\n      });\n  };\n\n  const singularOrPlural = (word: string, count: number) => {\n    return count > 1 ? inflection.pluralize(word) : inflection.singularize(word);\n  };\n\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\") && !/^\\$\\d/.test(value)) {\n        const similarNames = recommend(\"vars\", value);\n        const typeName = singularOrPlural(\"variable\", similarNames.length);\n        const areIs = similarNames.length > 1 ? \"are\" : \"is\";\n        const recommendations = ` The most similar ${typeName} ${areIs} ${similarNames.join(\", \")}`;\n        warnings_push(\"Unknown variable '\" + value + \"'.\" + (similarNames.length > 0 ? recommendations : \"\"));\n\n        if (value in (ctx.funcs || {})) {\n          warnings_push(\"'\" + value + \"' is defined as a function.\");\n        }\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\") && !/^\\$\\d/.test(name)) {\n      const similarNames = recommend(\"funcs\", name);\n      const typeName = singularOrPlural(\"function\", similarNames.length);\n      const areIs = similarNames.length > 1 ? \"are\" : \"is\";\n      const recommendations = ` The most similar ${typeName} ${areIs} ${similarNames.join(\", \")}`;\n      warnings_push(\"Unknown function '\" + name + \"'.\" + (similarNames.length > 0 ? recommendations : \"\"));\n\n      if (name in (ctx.vars || {})) {\n        warnings_push(\"'\" + name + \"' is defined as a variable.\");\n      }\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, type EvalWarningMeta, Lexer, parseExpr, runExpr } from \"./eval\";\nimport { AnyFn, type TypeOf } from \"../@types\";\nimport date from \"../date\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nexport type ParserLogsLevel = \"WARN\" | \"ERROR\";\nexport type ParserLog = EvalWarningMeta & {\n  level: \"WARN\" | \"ERROR\",\n  lineNumber: number,\n  error?: Error,\n};\n\nexport type ParseTemplateResult = {\n  result: string,\n  logs: ParserLog[],\n};\n\n/**\n *\n * @param sentence sentence\n * @param _ctx context\n * @returns evaludated sentence\n *\n * @deprecated use `class TemplateParser` or `lval` function\n */\nconst parseTemplate = (sentence: string, _ctx: EvalContext = {}): ParseTemplateResult => {\n  const logs: ParserLog[] = [];\n\n  const result = sentence\n    .split(\"\\n\")\n    .map((line, index) => {\n      try {\n        const parsed = _parseTemplate(line, _ctx);\n        logs.push(...parsed.warnings.map((wranMeta) => ({\n          lineNumber: index + 1,\n          level: \"WARN\" as const,\n          ...wranMeta,\n        })));\n\n        return parsed.result;\n      } catch (error: any) {\n\n        if (error.message.toLowerCase().startsWith(\"no primary expression starts with ')'\") || error.message.startsWith(\"Expected ')' but got '\")) {\n          const modded = line.replace(/(\\W)\\(([^)]+)\\)/g, \"$1 <parentheses> $2 </parentheses>\");\n\n          try {\n            const parsed = _parseTemplate(modded, _ctx);\n            logs.push(...parsed.warnings.map((wranMeta) => ({\n              lineNumber: index + 1,\n              level: \"WARN\" as const,\n              ...wranMeta,\n            })));\n            return parsed\n              .result\n              .replace(/<parentheses> /gi, \"(\")\n              .replace(/ <\\/parentheses>/gi, \")\");\n          } catch (ignored) { /* emtpy */ }\n        }\n\n        let message = \"\";\n\n        if (error) {\n          message = error.message;\n          if (!message && error.toString) {\n            message = error.toString();\n          }\n        }\n\n        if (!message) {\n          message = `${error}`;\n        }\n\n        logs.push({\n          lineNumber: index + 1,\n          level: \"ERROR\",\n          message,\n          error,\n          timestamp: new Date(),\n        });\n      }\n\n      return line;\n    })\n    .join(\"\\n\");\n  return {\n    result,\n    logs,\n  };\n};\n\nconst _parseTemplate = (sentence: string, _ctx: EvalContext = {}) => {\n  const warnings: EvalWarningMeta[] = [];\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      let isParenOpen = word.endsWith(\"(\");\n      let isParenClose = word.endsWith(\")\");\n      let isGt = word.endsWith(\">\");\n      let isLt = word.endsWith(\"<\");\n      while (word && (isPeriod || isExcla || isParenOpen || isParenClose || isGt || isLt)) {\n        word = word.substring(0, word.length - 1);\n\n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        } else if (isParenOpen) {\n          cutHist.push(\"(\");\n        } else if (isParenClose) {\n          cutHist.push(\")\");\n        } else if (isGt) {\n          cutHist.push(\">\");\n        } else if (isLt) {\n          cutHist.push(\"<\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n        isParenOpen = word.endsWith(\"(\");\n        isParenClose = word.endsWith(\")\");\n        isGt = word.endsWith(\">\");\n        isLt = word.endsWith(\"<\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }\n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx, /*&mut*/warnings);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n\n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && ![\"!\", \".\", \",\"].includes(lex.nextToken() as string)) {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return {\n    result: builder.join(\"\").trim(),\n    warnings,\n  };\n};\n\nexport type Context = EvalContext;\nexport type TemplateParserOptions = {\n  includeBuiltIns: boolean,\n};\nclass TemplateParser {\n  constructor(\n    public options: TemplateParserOptions = {\n      includeBuiltIns: true,\n    },\n    public ctx: Context = {},\n    public logs: ParserLog[] = [],\n  ) {\n\n    if (this.options.includeBuiltIns) {\n      this.ctx.funcs = {\n        ...this.builtinFunctions(),\n        ...(this.ctx.funcs || {}),\n      };\n    }\n  }\n\n  builtinFunctions() {\n    const $abs = (x: any): number => Math.abs(x);\n    const $all = (...args: any[]): boolean => {\n      return args.map($bool).every((x) => x === true);\n    };\n    const $any = (...args: any[]): boolean => {\n      return args.map($bool).some((x) => x === true);\n    };\n\n    const $bool = (x: any): boolean => {\n      if (check.isValidBoolean(x)) {\n        return check.isTrue(x);\n      }\n\n      return !!x && $isset(x);\n    };\n    const $float = (x: any): number => parseFloat(x);\n    const $str = (x: any): string => {\n      if ($isnil(x)) {\n        return `${x}`;\n      }\n\n      if (check.isObject(x)) {\n\n        try {\n          x = JSON.stringify(x);\n        } catch (ignored) {\n          const circularReference: any[] = [];\n          const jsonString = JSON.stringify(x, (key, value) => {\n            if (typeof value === \"bigint\") {\n              return value.toString();\n            }\n            if (typeof value === \"object\" && value !== null) {\n              if (circularReference.includes(value)) {\n                return \"[Circular]\";\n              }\n              circularReference.push(value);\n            }\n            return value;\n          });\n\n          // Replace circular references with actual object reference\n          x = jsonString.replace(/\"\\[Circular\\]\"/g, () => {\n            return JSON.stringify(\"[Circular]\");\n          });\n        }\n      }\n\n      if (!check.isString(x)) {\n        x = x.toString ? x.toString() : `${x}`;\n      }\n\n      return x;\n    };\n\n    const $format = (fmt: string, ...args: any[]): string => {\n      if (!check.isString(fmt) || args.length === 0) {\n        return fmt;\n      }\n      args.map($str).forEach((variable, index) => {\n        const template = `{${index}}`;\n        while (fmt.includes(template)) {\n          fmt = fmt.replace(template, variable);\n        }\n      });\n\n      return fmt;\n    };\n\n    const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n      return $bool(condition) ? ifTrue : ifFalse;\n    };\n\n    const $int = (x: any): number => parseInt(x);\n    const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n      const xType = $type(x);\n      return types.map($str).some((t) => xType === t);\n    };\n\n    const $tisstring = (x: any) => {\n      return $isinstance(x, \"string\");\n    };\n    const $tisnumber = (x: any) => {\n      return $isinstance(x, \"number\", \"bigint\");\n    };\n    const $tisundefined = (x: any) => {\n      return $isinstance(x, \"undefined\");\n    };\n    const $tisobject = (x: any) => {\n      return $isinstance(x, \"object\");\n    };\n    const $tisboolean = (x: any) => {\n      return $isinstance(x, \"boolean\");\n    };\n    const $isnil = (x: any) => {\n      return x === null || x === undefined;\n    };\n\n    const $endsWith = (x: any, searchString: string, endPos?: number) => {\n      x = $str(x);\n      searchString = $str(searchString);\n      return x.endsWith(searchString, endPos);\n    };\n    const $startsWith = (x: any, searchString: string, pos?: number) => {\n      return $str(x).startsWith(searchString, pos);\n    };\n    const $lower = (x: any) => {\n      return $str(x).toLowerCase();\n\n    };\n    const $upper = (x: any) => {\n      return $str(x).toUpperCase();\n    };\n\n    const $len = (x: any): number => {\n      return $str(x).length;\n    };\n\n    const $max = (...args: any[]): any => {\n      return Math.max(\n        ...args\n          .map($str)\n          .map($float)\n          .filter((x) => !isNaN(x))\n      );\n    };\n    const $min = (...args: any[]): any => {\n      return Math.min(\n        ...args\n          .map($str)\n          .map($float)\n          .filter((x) => !isNaN(x))\n      );\n    };\n\n    const $pow = (a: number, b: number) => Math.pow(a, b);\n    const $round = (a: number) => Math.round(a);\n    const $math = (key: string, ...args: any[]) => {\n      try {\n        const intrinsic = (Math as any)[key];\n        const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n        if (result) {\n          return result;\n        }\n      } catch (error: any) {\n        this.logs.push({\n          level: \"ERROR\",\n          error,\n          message: error.message || `${error}`,\n          lineNumber: NaN,\n          timestamp: new Date(),\n        });\n      }\n\n      const argv = args.join(\", \");\n      this.logs.push({\n        level: \"WARN\",\n        lineNumber: NaN,\n        message: `Couldn't resolve Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`,\n        timestamp: new Date(),\n      });\n      return `$math('${key}'${!argv ? \"\" : \", \" + argv})`;\n    };\n    const $concat = (...args: any[]) => {\n      return args.map($str).join(\"\");\n    };\n    const $substring = (x: string, start: number, end?: number) => {\n      const str = $str(x);\n      if (start === undefined || !check.isNumber(start) || start < 0) {\n        start = 0;\n      }\n      if (end === undefined || !check.isNumber(start) || end > str.length) {\n        end = str.length;\n      }\n      return str.substring(start, end);\n\n    };\n    const $type = (x: any) => typeof x;\n    const $getattr = (obj: any, ...path: string[]) => {\n      let ptr = obj;\n      path.filter(check.isString).forEach((literalKey) => {\n        // Split key into parts on '.'\n        let keys = literalKey.split(\".\");\n\n        // Check if first attr exists if not revert back\n        // to original key\n        if (!ptr[keys[0]]) {\n          keys = [literalKey];\n        }\n\n        keys\n          .filter((x) => !!x)\n          .forEach((key) => {\n            if (ptr && key && ptr[key]) {\n              ptr = ptr[key];\n            }\n          });\n      });\n\n\n      return ptr;\n    };\n\n    const $hasattr = (obj: any, ...path: string[]) => {\n      let ptr = obj;\n      let result = true;\n      path.filter(check.isString).forEach((literalKey) => {\n        // Split key into parts on '.'\n        let keys = literalKey.split(\".\");\n\n        // Check if first attr exists if not revert back\n        // to original key\n        if (!ptr[keys[0]]) {\n          keys = [literalKey];\n        }\n\n        keys\n          .filter((x) => !!x)\n          .forEach((key) => {\n            if (ptr && key && ptr[key]) {\n              ptr = ptr[key];\n            } else {\n              result = false;\n            }\n          });\n      });\n\n\n      return result;\n    };\n    const $isset = (obj: any) => {\n      return !$str(obj).startsWith(\"$\");\n    };\n\n    const $includes = (x: any, value: any) => {\n      if (x) {\n        if (x.includes && check.isFunction(x.includes)) {\n          return x.includes(value);\n        }\n\n        if (x.has && check.isFunction(x.has)) {\n          return x.has(value);\n        }\n      }\n\n      return false;\n    };\n\n    const $now = () => {\n      return new Date();\n    };\n\n    return {\n      $if,\n      $abs,\n      $all,\n      $any,\n      $bool,\n      $float,\n      $str,\n      $format,\n      $int,\n      $isnil,\n      $isinstance,\n      $tisstring,\n      $tisnumber,\n      $tisboolean,\n      $tisundefined,\n      $tisobject,\n      $len,\n      $max,\n      $min,\n      $pow,\n      $round,\n      $substring,\n      $type,\n      $math,\n      $getattr,\n      $concat,\n      $hasattr,\n      $isset,\n      $includes,\n      $endsWith,\n      $startsWith,\n      $lower,\n      $upper,\n      $now,\n    };\n  }\n\n  fixName(name: string) {\n    return name.startsWith(\"$\") ? name : \"$\" + name;\n  }\n\n  fnExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.funcs || {});\n  }\n\n  varExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.vars || {});\n  }\n\n  addVar(name: string, value: any) {\n    name = this.fixName(name);\n    this.ctx.vars = this.ctx.vars || {};\n    this.ctx.vars[name] = value;\n  }\n\n  addFunction(name: string, cb: AnyFn) {\n    name = this.fixName(name);\n    this.ctx.funcs = this.ctx.funcs || {};\n    this.ctx.funcs[name] = cb;\n  }\n\n  clearLogs() {\n    this.logs = [];\n  }\n\n  parse(sentence: string): ParseTemplateResult {\n    const result = parseTemplate(sentence, this.ctx || {});\n    this.logs.push(...result.logs);\n    return result;\n  }\n}\n\nconst _lvalParseString = <T>(str: string) => {\n  if (check.isNumeric(str)) {\n    return parseFloat(str);\n  } else if (check.isValidBoolean(str)) {\n    return check.isTrue(str);\n  } else if (date.parse(str) !== null) {\n    return new Date(str);\n  } else if (str === \"undefined\") {\n    return undefined;\n  } else if (str === \"null\") {\n    return null;\n  }\n\n  try {\n    return JSON.parse(str) as T;\n  } catch(err) {\n    return str;\n  }\n};\n\nconst lval = <T>(sentence: string, ctx?: Context) => {\n  const r = parseTemplate(sentence, ctx || {});\n  const expr = _lvalParseString<T>(r.result);\n  return {\n    result: expr,\n    logs: r.logs,\n  };\n};\n\nconst ____builtins = new TemplateParser({ includeBuiltIns: false }).builtinFunctions;\nexport type BuiltInFunction = ReturnType<typeof ____builtins>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\n\nexport default {\n  /** @deprecated change `SentenceParser` to `TemplateParser`  */\n  SentenceParser: TemplateParser,\n  TemplateParser,\n  lval,\n};\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "src_default", "types_exports", "sorted_exports", "__export", "BisectArray", "ReverseCompareArray", "ReverseNumberArray", "ReverseSortedArray", "ReverseStringArray", "SortedArray", "SortedCompareArray", "SortedNumberArray", "SortedStringArray", "isWeekend", "date", "day", "between", "startDate", "endDate", "parse", "input", "inputDate", "timeSince", "seconds", "interval", "date_default", "isNumber", "x", "isBigInt", "isString", "isBoolean", "isFunction", "isObject", "isNil", "isArray", "isSet", "isIterable", "isNumeric", "isValidBoolean", "isNum", "isStr", "alts", "len", "valueOf", "isTrue", "valueOfX", "y", "isFalse", "isDate", "date_default", "isError", "errorLike", "check_default", "BisectArray", "opts", "items", "b", "item", "index", "left", "right", "mid", "a", "keyA", "keyB", "check_default", "ReverseSortedArray", "key", "SortedArray", "ReverseNumberArray", "SortedNumberArray", "ReverseStringArray", "SortedStringArray", "ReverseCompareArray", "cmp", "SortedCompareArray", "array_default", "__spreadValues", "sorted_exports", "patienceDiff", "aLines", "bLines", "diffPlusFlag", "findUnique", "arr", "lo", "hi", "lineMap", "i", "line", "val", "key", "map", "uniqueCommon", "aArray", "aLo", "aHi", "bArray", "bLo", "bHi", "ma", "mb", "longestCommonSubsequence", "abMap", "ja", "_key", "_map", "lcs", "n", "result", "deleted", "inserted", "aMove", "aMoveIndex", "bMove", "bMoveIndex", "addToResult", "aIndex", "bIndex", "addSubMatch", "aHiTemp", "uniqueCommonMap", "recurseLCS", "x", "___IGNORE", "compare", "a", "b", "desc", "index", "changeType", "diff_default", "similarity", "str1", "str2", "gramSize", "getNGrams", "s", "len", "v", "i", "s1", "s2", "pairs1", "pairs2", "set", "total", "hits", "item", "topSimilar", "value", "values", "key", "topK", "thresh", "keysim", "arr", "ReverseSortedArray", "x", "cachedScore", "score", "popped", "fuzzy_default", "hashCode", "str", "coerceToString", "check_default", "ignored", "circularReference", "key", "value", "hash", "i", "code", "capitalize", "utils_default", "PLURALS", "SINGULARS", "UNCOUNTABLES", "_irregular", "singular", "plural", "caseinsensitive", "x", "char", "insert", "arr", "index", "elem", "pluralInsert", "singularInsert", "camelize", "string", "uppercaseFirstLetter", "camelCase", "dasherize", "word", "humanize", "m", "ordinal", "number", "n", "ordinalize", "parameterize", "separator", "param", "transliterate", "pluralize", "isUpper", "endsWithLetter", "rule", "replacement", "result", "utils_default", "singularize", "u", "tableize", "underscore", "titleize", "underscored", "inflection_default", "__SAVE", "BIN_PREC", "BINARY_OPS", "lhs", "rhs", "check_default", "UNARY_OPS", "arg", "Lexer", "src", "hist", "syntax", "alreadyCrashed", "token", "isTokenBreak", "c", "isDouble", "isSingle", "isSOFStr", "strEnd", "valid", "spaceCount", "parsePrimary", "lexer", "operand", "parseExpr", "expr", "nextToken", "args", "prec", "opToken", "runExpr", "ctx", "warnings", "warnings_push", "message", "recommend", "ctxKey", "value", "fuzzy_default", "x", "str", "i", "singularOrPlural", "word", "count", "inflection_default", "number", "similarNames", "typeName", "areIs", "recommendations", "unary_op", "op", "binary_op", "funcall", "name", "_a", "params", "fixString", "x", "check_default", "wrapCtxFuncs", "mut_ctx", "_f", "f", "__spreadValues", "updated", "k", "args", "parseTemplate", "sentence", "_ctx", "logs", "line", "index", "parsed", "_parseTemplate", "wranMeta", "error", "modded", "ignored", "message", "_a", "warnings", "ctx", "lex", "Lexer", "builder", "_restore", "restoreSpace", "expr", "parseExpr", "word", "cutHist", "isPeriod", "isExcla", "isParenOpen", "isParenClose", "isGt", "isLt", "isFuncCall", "isSymbol", "resolved", "runExpr", "append", "isVar", "commaLoc", "TemplateParser", "options", "$abs", "$all", "$bool", "$any", "$isset", "$float", "$str", "$isnil", "circularReference", "key", "value", "$format", "fmt", "variable", "template", "$if", "condition", "ifTrue", "ifFalse", "$int", "$isinstance", "types", "xType", "$type", "t", "$tisstring", "$tisnumber", "$tisundefined", "$tisobject", "$tisboolean", "$endsWith", "searchString", "endPos", "$startsWith", "pos", "$lower", "$upper", "$len", "$max", "$min", "$pow", "a", "b", "$round", "$math", "intrinsic", "result", "argv", "$concat", "$substring", "start", "end", "str", "$getattr", "obj", "path", "ptr", "literalKey", "keys", "$hasattr", "name", "cb", "_lvalParseString", "date_default", "err", "lval", "r", "____builtins", "template_default", "src_default", "__spreadValues", "check_default", "template_default", "inflection_default", "utils_default", "date_default", "fuzzy_default", "array_default", "diff_default", "types_exports"]
}
