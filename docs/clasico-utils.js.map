{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/check/index.ts", "../../src/eval/eval.ts", "../../src/eval/index.ts", "../../src/utils/index.ts", "../../src/inlfection/index.ts", "../../src/@types/index.ts"],
  "sourcesContent": ["import check from \"./check\";\nimport eval from \"./eval\";\nimport inflection from \"./inlfection\";\nimport utils from \"./utils\";\nimport * as types from \"./@types\"; \n\nexport default {\n  check,\n  eval,\n  inflection,\n  utils,\n\n  ...types,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst TRUE = new Boolean(true);\nconst FALSE = new Boolean(false);\nconst BOOLEANS = [true, TRUE, false, FALSE];\n\nconst isNumber = (x: any) => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n    || typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: any) => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: any) => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n    || BOOLEANS.includes(x)\n  );\n};\n\nconst isFunction = (x: any) => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: any) => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: any) => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: any) => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: any) => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\nconst isIterable = (x: any) => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: any) => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  return !isNaN(x) && !isNaN(parseFloat(x));\n};\n\nconst isValidBoolean = (x: any) => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      TRUE,\n      FALSE,\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isTrue = (x: any) => {\n  if (x && x.toString && x.toString() === \"true\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    const alts = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      TRUE,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isString(x)) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: any) => {\n  if (x && x.toString && x.toString() === \"false\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\n// @exports\nexport default {\n  isNumber,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM),\n// which is licensed under the MIT License.\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport { type AnyFn } from \"../@types\";\nimport check from \"../check\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n\n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}): any => {\n  console.assert(check.isObject(expr));\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\")) {\n        console.warn(\"WARN: Unknown variable '\" + value + \"'\");\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\")) {\n      console.warn(\"WARN: Unknown function '\" + name + \"'\");\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, Lexer, parseExpr, runExpr } from \"./eval\";\nimport { type TypeOf } from \"../@types\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nconst builtinFunctions = () => {\n  const $abs = (x: any): number => Math.abs(x);\n  const $all = (...args: any[]): boolean => {\n    return args.map($bool).every((x) => x === true);\n  };\n  const $any = (...args: any[]): boolean => {\n    return args.map($bool).some((x) => x === true);\n  };\n\n  const $bool = (x: any): boolean => {\n    if (check.isValidBoolean(x)) {\n      return check.isTrue(x);\n    }\n\n    return !!x && $isset(x);\n  };\n  const $float = (x: any): number => parseFloat(x);\n  const $str = (x: any): string => {\n    if (check.isObject(x)) {\n      x = JSON.stringify(x, null, 0);\n    }\n\n    if (!check.isString(x)) {\n      x = x.toString ? x.toString() : `${x}`;\n    }\n\n    return x;\n  };\n\n  const $format = (fmt: string, ...args: any[]): string => {\n    if (!check.isString(fmt) || args.length === 0) {\n      return fmt;\n    }\n    args.map($str).forEach((variable, index) => {\n      const template = `{${index}}`;\n      while (fmt.includes(template)) {\n        fmt = fmt.replace(template, variable);\n      }\n    });\n\n    return fmt;\n  };\n\n  // const $hash = (x: string): number => {\n  //   x = $str(x);\n  //   let hash = 0;\n  //   for (let i = 0; i < x.length; ++i) {\n  //     const code = x.charCodeAt(i);\n  //     hash = ((hash << 5) - hash) + code;\n  //     hash &= hash;\n  //   }\n  //   return hash;\n  // };\n\n  const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n    return $bool(condition) ? ifTrue : ifFalse;\n  };\n\n  const $int = (x: any): number => parseInt(x);\n  const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n    const xType = $type(x);\n    return types.map($str).some((t) => xType === t);\n  };\n\n  const $tisstring = (x: any) => {\n    return $isinstance(x, \"string\");\n  };\n  const $tisnumber = (x: any) => {\n    return $isinstance(x, \"number\", \"bigint\");\n  };\n  const $tisundefined = (x: any) => {\n    return $isinstance(x, \"undefined\");\n  };\n  const $tisobject = (x: any) => {\n    return $isinstance(x, \"object\");\n  };\n  const $tisboolean = (x: any) => {\n    return $isinstance(x, \"boolean\");\n  };\n  const $isnil = (x: any) => {\n    return x === null || x === undefined;\n  };\n\n  const $endsWith = (x: any, searchString: string, endPos?: number) => {\n    x = $str(x);\n    searchString = $str(searchString);\n    return x.endsWith(searchString, endPos);\n  };\n  const $startsWith = (x: any, searchString: string, pos?: number) => {\n    return $str(x).startsWith(searchString, pos);\n  };\n  const $lower = (x: any) => {\n    return $str(x).toLowerCase();\n\n  };\n  const $upper = (x: any) => {\n    return $str(x).toUpperCase();\n  };\n\n  const $len = (x: any): number => {\n    return $str(x).length;\n  };\n\n  const $max = (...args: any[]): any => {\n    return Math.max(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n  const $min = (...args: any[]): any => {\n    return Math.min(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n\n  const $pow = (a: number, b: number) => Math.pow(a, b);\n  const $round = (a: number) => Math.round(a);\n  const $math = (key: string, ...args: any[]) => {\n    try {\n      const intrinsic = (Math as any)[key];\n      const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n      if (result) {\n        return result;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    const argv = args.join(\", \");\n    return `Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`;\n  };\n  const $concat = (...args: any[]) => {\n    return args.map($str).join(\"\");\n  };\n  const $substring = (x: string, start: number, end?: number) => {\n    const str = $str(x);\n    if (start === undefined || !check.isNumber(start) || start < 0) {\n      start = 0;\n    }\n    if (end === undefined || !check.isNumber(start) || end > str.length) {\n      end = str.length;\n    }\n    return str.substring(start, end);\n\n  };\n  const $type = (x: any) => typeof x;\n  const $getattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          }\n        });\n    });\n\n\n    return ptr;\n  };\n\n  const $hasattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    let result = true;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          } else {\n            result = false;\n          }\n        });\n    });\n\n\n    return result;\n  };\n  const $isset = (obj: any) => {\n    return !$str(obj).startsWith(\"$\");\n  };\n\n  const $includes = (x: any, value: any) => {\n    if (x) {\n      if (x.includes && check.isFunction(x.includes)) {\n        return x.includes(value);\n      }\n\n      if (x.has && check.isFunction(x.has)) {\n        return x.has(value);\n      }\n    }\n\n    return false;\n  };\n\n  return {\n    $if,\n    $abs,\n    $all,\n    $any,\n    $bool,\n    $float,\n    $str,\n    $format,\n    $int,\n    $isnil,\n    $isinstance,\n    $tisstring,\n    $tisnumber,\n    $tisboolean,\n    $tisundefined,\n    $tisobject,\n    $len,\n    $max,\n    $min,\n    $pow,\n    $round,\n    $substring,\n    $type,\n    $math,\n    $getattr,\n    $concat,\n    $hasattr,\n    $isset,\n    $includes,\n    $endsWith,\n    $startsWith,\n    $lower,\n    $upper,\n  };\n};\n\nconst parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  return sentence\n    .split(\"\\n\")\n    .map((line) => _parseSentence(line , _ctx))\n    .join(\"\\n\");\n};\n\nconst _parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      while (word && (isPeriod || isExcla)) {\n        word = word.substring(0, word.length - 1);\n\n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }\n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n\n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && lex.nextToken() !== \"!\") {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return builder.join(\"\").trim();\n};\n\n// @exports\nexport type BuiltInFunction = ReturnType<typeof builtinFunctions>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\nexport type Context = EvalContext;\n\nexport default {\n  builtinFunctions,\n  parseSentence,\n};\n", "import check from \"../check\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst hashCode = (str: any, coerceToString=true): number | null => {\n\n  if (coerceToString) {\n    if (!check.isString(str)) {\n      if (check.isSet(str)) {\n        str = Array.from(str);\n      }\n\n      if (check.isObject(str)) {\n        try {\n          str = JSON.stringify(str);\n          // eslint-disable-next-line no-empty\n        } catch(ignoerd) {}\n      }\n\n      if (!check.isString(str) && str.toString) {\n        str = str.toString();\n      }\n    }\n  }\n\n  if (!check.isString(str)) {\n    return null;\n  }\n\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nconst capitalize = (str: string) => {\n  if (!check.isString(str)) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport default {\n  hashCode,\n  capitalize,\n};", "\n// This code is a port of (i.e., based on) the inflection project (https://github.com/jpvanhal/inflection),\n// which is licensed under the MIT License.\n// Copyright (C) 2012-2020 Janne Vanhala\n\nimport utils from \"../utils\";\n\n\nexport type RegexReplaceList = [RegExp, string][]\n\nconst PLURALS: RegexReplaceList = [\n  [/(quiz)$/i, \"$1zes\"],\n  [/^(oxen)$/i, \"$1\"],\n  [/^(ox)$/i, \"$1en\"],\n  [/(m|l)ice$/i, \"$1ice\"],\n  [/(m|l)ouse$/i, \"$1ice\"],\n  [/(passer)s?by$/i, \"$1sby\"],\n  [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n  [/(x|ch|ss|sh)$/i, \"$1es\"],\n  [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n  [/(hive)$/i, \"$1s\"],\n  [/([lr])f$/i, \"$1ves\"],\n  [/([^f])fe$/i, \"$1ves\"],\n  [/sis$/i, \"ses\"],\n  [/([ti])a$/i, \"$1a\"],\n  [/([ti])um$/i, \"$1a\"],\n  [/(buffal|potat|tomat)o$/i, \"$1oes\"],\n  [/(bu)s$/i, \"$1ses\"],\n  [/(alias|status)$/i, \"$1es\"],\n  [/(octop|vir)i$/i, \"$1i\"],\n  [/(octop|vir)us$/i, \"$1i\"],\n  [/^(ax|test)is$/i, \"$1es\"],\n  [/s$/i, \"s\"],\n  [/$/i, \"s\"],\n];\n\nconst SINGULARS: RegexReplaceList = [\n  [/(database)s$/i, \"$1\"],\n  [/(quiz)zes$/i, \"$1\"],\n  [/(matr)ices$/i, \"$1ix\"],\n  [/(vert|ind)ices$/i, \"$1ex\"],\n  [/(passer)sby$/i, \"$1by\"],\n  [/^(ox)en/i, \"$1\"],\n  [/(alias|status)(es)?$/i, \"$1\"],\n  [/(octop|vir)(us|i)$/i, \"$1us\"],\n  [/^(a)x[ie]s$/i, \"$1xis\"],\n  [/(cris|test)(is|es)$/i, \"$1is\"],\n  [/(shoe)s$/i, \"$1\"],\n  [/(o)es$/i, \"$1\"],\n  [/(bus)(es)?$/i, \"$1\"],\n  [/(m|l)ice$/i, \"$1ouse\"],\n  [/(x|ch|ss|sh)es$/i, \"$1\"],\n  [/(m)ovies$/i, \"$1ovie\"],\n  [/(s)eries$/i, \"$1eries\"],\n  [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n  [/([lr])ves$/i, \"$1f\"],\n  [/(tive)s$/i, \"$1\"],\n  [/(hive)s$/i, \"$1\"],\n  [/([^f])ves$/i, \"$1fe\"],\n  [/(t)he(sis|ses)$/i, \"$1hesis\"],\n  [/(s)ynop(sis|ses)$/i, \"$1ynopsis\"],\n  [/(p)rogno(sis|ses)$/i, \"$1rognosis\"],\n  [/(p)arenthe(sis|ses)$/i, \"$1arenthesis\"],\n  [/(d)iagno(sis|ses)$/i, \"$1iagnosis\"],\n  [/(b)a(sis|ses)$/i, \"$1asis\"],\n  [/(a)naly(sis|ses)$/i, \"$1nalysis\"],\n  [/([ti])a$/i, \"$1um\"],\n  [/(n)ews$/i, \"$1ews\"],\n  [/(ss)$/i, \"$1\"],\n  [/s$/i, \"\"],\n];\n\nconst UNCOUNTABLES = new Set([\n  \"equipment\",\n  \"fish\",\n  \"information\",\n  \"jeans\",\n  \"money\",\n  \"rice\",\n  \"series\",\n  \"sheep\",\n  \"species\",\n]);\n\n\n/**\n\nA convenience function to add appropriate rules to plurals and singular\nfor irregular words.\n\n@param singular: irregular word in singular form\n@param plural: irregular word in plural form\n */\nconst _irregular = (singular: string, plural: string): void => {\n  const caseinsensitive = (x: string): string => {\n    return Array\n      .from(x)\n      .map((char) => \"[\" + char + char.toUpperCase() + \"]\")\n      .join(\"\");\n  };\n\n  const insert = (arr: RegexReplaceList, index: number, elem: [string, string]) => {\n    arr.splice(index, 0, [new RegExp(elem[0], \"i\"), elem[1]]);\n  };\n\n  const pluralInsert = (index: number, elem: [string, string]) => {\n    insert(PLURALS, index, elem);\n  };\n\n  const singularInsert = (index: number, elem: [string, string]) => {\n    insert(SINGULARS, index, elem);\n  };\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    pluralInsert(0, [\n      `(${singular[0]})${singular.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + singular.slice(1)\n    ]);\n  } else {\n    pluralInsert(0, [\n      `${singular[0].toUpperCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${singular[0].toLowerCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toUpperCase() + singular.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toLowerCase() + singular.slice(1)\n    ]);\n  }\n};\n\nconst camelize = (string: string, uppercaseFirstLetter = true): string => {\n  const camelCase = dasherize(string)\n    .replace(/-/, \" \")\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(word, index) {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n\n  const result = uppercaseFirstLetter\n    ? camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\n    : camelCase;\n\n  return result;\n};\n\nfunction dasherize(word: string): string {\n  // Replace underscores with dashes in the string.\n  // Example: dasherize(\"puni_puni\") returns 'puni-puni'\n  return word.replace(/_/g, \"-\");\n}\n\nfunction humanize(word: string): string {\n  /*\n    Capitalize the first word and turn underscores into spaces and strip a\n    trailing \"_id\", if any. Like titleize, this is meant for creating pretty output.\n\n    Examples:\n\n    >>> humanize(\"employee_salary\")\n    'Employee salary'\n    >>> humanize(\"author_id\")\n    'Author'\n    */\n\n  word = word.replace(/_id$/i, \"\");\n  word = word.replace(/_/g, \" \");\n  word = word.replace(/([a-z\\d]*)/g, function (m) {\n    return m.toLowerCase();\n  });\n  word = word.replace(/^\\w/, function (m) {\n    return m.toUpperCase();\n  });\n  return word;\n}\n\nfunction ordinal(number: string): string {\n  /*\n    Return the suffix that should be added to a number to denote the position\n    in an ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n    >>> ordinal(1)\n    'st'\n    >>> ordinal(2)\n    'nd'\n    >>> ordinal(1002)\n    'nd'\n    >>> ordinal(1003)\n    'rd'\n    >>> ordinal(-11)\n    'th'\n    >>> ordinal(-1021)\n    'st'\n    */\n\n  const n = Math.abs(parseInt(number));\n  if ([11, 12, 13].includes(n % 100)) {\n    return \"th\";\n  } else {\n    switch (n % 10) {\n    case 1:\n      return \"st\";\n    case 2:\n      return \"nd\";\n    case 3:\n      return \"rd\";\n    default:\n      return \"th\";\n    }\n  }\n}\n\nfunction ordinalize(number: string) {\n  /*\n    Turn a number into an ordinal string used to denote the position in an\n    ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n\n    >>> ordinalize(1)\n    '1st'\n    >>> ordinalize(2)\n    '2nd'\n    >>> ordinalize(1002)\n    '1002nd'\n    >>> ordinalize(1003)\n    '1003rd'\n    >>> ordinalize(-11)\n    '-11th'\n    >>> ordinalize(-1021)\n    '-1021st'\n    */\n\n  return number + ordinal(number);\n}\n\nconst parameterize = (string: string, separator = \"-\") => {\n  const cleaned = transliterate(string);\n  let param = cleaned.replace(/[^\\d\\w-]+/gmi, separator);\n  if (separator !== \"\") {\n    while (param.startsWith(separator)) {\n      param = param.slice(separator.length);\n    }\n\n    while (param.endsWith(separator)) {\n      param = param.slice(0, param.length - separator.length);\n    }\n  }\n  return param.toLowerCase();\n};\n\nconst pluralize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  if (!word || UNCOUNTABLES.has(word.toLowerCase())) {\n    return word;\n  } else {\n    for (const elem of PLURALS) {\n      const rule = elem[0];\n      const replacement = elem[1];\n      if (rule.test(word)) {\n        const result = word.replace(rule, replacement);\n        return isUpper ? utils.capitalize(result) : result;\n      }\n    }\n    return word;\n  }\n};\n\nconst singularize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  for (const u of UNCOUNTABLES) {\n    const regex = new RegExp(`\\\\b${u}\\\\b`, \"i\");\n    if (regex.test(word)) {\n      return word;\n    }\n  }\n\n  for (const elem of SINGULARS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n  return word;\n};\n\nconst tableize = (word: string): string => {\n  return pluralize(underscore(word));\n};\n\nfunction titleize(word: string) {\n  return humanize(underscore(word))\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n}\n\n\nfunction transliterate(string: string) {\n  const normalized = string.normalize(\"NFKD\");\n  return normalized\n    .replace(/[\\u0300-\\u036f]/g, \"\") // remove combining diacritical marks\n    // eslint-disable-next-line no-control-regex\n    .replace(/[^\\x00-\\x7F]/g, \"\") // remove non-ASCII characters\n    .trim();\n}\n\nfunction underscore(word: string) {\n  let underscored = word.replace(/([a-z\\d])([A-Z])/g, \"$1_$2\"); // split camelCase\n  underscored = underscored.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\"); // split PascalCase\n  underscored = underscored.replace(/-/g, \"_\"); // replace hyphens with underscores\n  return underscored.toLowerCase();\n}\n\n\n\n_irregular(\"person\", \"people\");\n_irregular(\"man\", \"men\");\n_irregular(\"human\", \"humans\");\n_irregular(\"child\", \"children\");\n_irregular(\"sex\", \"sexes\");\n_irregular(\"move\", \"moves\");\n_irregular(\"cow\", \"kine\");\n_irregular(\"zombie\", \"zombies\");\n\nexport default {\n  camelize,\n  dasherize,\n  humanize,\n  ordinal,\n  ordinalize,\n  parameterize,\n  pluralize,\n  singularize,\n  tableize,\n  titleize,\n  transliterate,\n  underscore,\n\n  UNCOUNTABLES,\n  PLURALS,\n  SINGULARS,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\n"],
  "mappings": "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",
  "names": ["x", "token", "word"]
}
