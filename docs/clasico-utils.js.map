{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/@types/index.ts", "../../src/array/sorted.ts", "../../src/date/index.ts", "../../src/check/index.ts", "../../src/array/index.ts", "../../src/diff/index.ts", "../../src/eval/eval.ts", "../../src/eval/index.ts", "../../src/fuzzy/index.ts", "../../src/utils/index.ts", "../../src/inflection/index.ts", "../../src/std/index.ts"],
  "sourcesContent": ["import * as types from \"./@types\";\nimport array from \"./array\";\nimport check from \"./check\";\nimport date from \"./date\";\nimport diff from \"./diff\";\nimport parser from \"./eval\";\nimport fuzzy from \"./fuzzy\";\nimport inflection from \"./inflection\";\nimport * as std from \"./std\";\nimport utils from \"./utils\";\n\nexport default {\n  check,\n  parser,\n  inflection,\n  utils,\n  date,\n  fuzzy,\n  array,\n  diff,\n  std,\n  ...types,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\n", "import check from \"../check\";\n\nexport type BisectArrayOptions<T> = {\n    key: (a: T) => number,\n    cmp?: (a: T, b: T) => number,\n    asReversed: boolean,\n    items: T[]\n};\n\nexport class BisectArray<TData> extends Array<TData> {\n  constructor(private opts: BisectArrayOptions<TData>) {\n    const items = opts.items;\n    super(...items);\n    if (this.isValidCmp()) {\n      this.sort(this.opts.cmp);\n    } else {\n      this.sort((a, b) => this.opts.key(a) - this.opts.key(b));\n    }\n\n    if (this.opts.asReversed) {\n      this.reverse();\n    }\n  }\n\n  pop(): TData | undefined {\n    return this.isReversed() ? super.pop() : super.shift();\n  }\n\n  push(...items: TData[]): number {\n    for (const item of items) {\n      const index = this.binarySearch(item);\n      this.splice(index, 0, item);\n    }\n    return this.length;\n  }\n\n  private binarySearch(item: TData): number {\n    let left = 0;\n    let right = this.length - 1;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.shouldSwap(this[mid], item)) {\n        left = mid + 1;\n      } else if (this.shouldSwap(item, this[mid])) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return left;\n  }\n\n  private shouldSwap(a: TData, b: TData): boolean {\n    if (this.opts.cmp && this.isValidCmp()) {\n      return this.isReversed() ?  this.opts.cmp(b, a) <= 0 : this.opts.cmp(a, b) <= 0;\n    }\n    const keyA = this.opts.key(a);\n    const keyB = this.opts.key(b);\n    return (this.isReversed() ? keyB - keyA <= 0 : keyA - keyB <= 0);\n  }\n\n  isValidCmp() {\n    return this.opts.cmp && check.isFunction(this.opts.cmp);\n  }\n\n  public isReversed() {\n    return this.opts.asReversed;\n  }\n}\n\nexport class ReverseSortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: true, items});\n  }\n}\n\nexport class SortedArray<T> extends BisectArray<T> {\n  constructor(\n    key: (key: T) => number,\n    ...items: T[]\n  ) {\n    super({key, asReversed: false, items});\n  }\n}\n\nexport class ReverseNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: true, items});\n  }\n}\n\nexport class SortedNumberArray extends BisectArray<number> {\n  constructor(\n    ...items: number[]\n  ) {\n    super({key: (a) => a, asReversed: false, items});\n  }\n}\n\nexport class ReverseStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class SortedStringArray extends BisectArray<string> {\n  constructor(\n    ...items: string[]\n  ) {\n    super({key: () => 0, cmp: (a, b) => a.localeCompare(b), asReversed: true, items});\n  }\n}\n\nexport class ReverseCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}\n\nexport class SortedCompareArray<T> extends BisectArray<T> {\n  constructor(\n    cmp: (a: T, b: T) => number,\n    ...items: T[]\n  ) {\n    super({key: () => 0, cmp, asReversed: true, items});\n  }\n}", "const subtractSeconds = (date: Date, seconds: number) => {\n  date.setSeconds(date.getSeconds() - seconds);\n  return date;\n};\n\nconst isWeekend = (date: Date) => {\n  const day = date.getDay(); // get day of week as integer (0 - 6)\n  // 0 is Sunday, 6 is Saturday\n  return day === 0 || day === 6;\n};\n\nconst between = (date: Date, startDate: Date, endDate: Date) => {\n  return date >= startDate && date <= endDate;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst parse = (input: any): Date | null => {\n  try {\n    const inputDate = new Date(input);\n    const isValidDate = !isNaN(inputDate.getTime());\n\n    if (isValidDate) {\n      return inputDate;\n    }\n  } catch (ignored) { /* empty */ }\n\n  return null;\n};\n\nexport default {\n  subtractSeconds,\n  parse,\n  isWeekend,\n  between,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport date from \"../date\";\n\nconst TRUE = new Boolean(true);\nconst FALSE = new Boolean(false);\nconst BOOLEANS = [true, TRUE, false, FALSE];\n\nconst isNumber = (x: any): boolean => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n    || typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: any): boolean => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: any): boolean => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n    || BOOLEANS.includes(x)\n  );\n};\n\nconst isFunction = (x: any): boolean => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: any): boolean => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: any): boolean => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: any): boolean => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: any): boolean => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\nconst isIterable = (x: any): boolean => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: any): boolean => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  return !isNaN(x) && !isNaN(parseFloat(x));\n};\n\nconst isValidBoolean = (x: any): boolean => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      TRUE,\n      FALSE,\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isTrue = (x: any): boolean => {\n  if (x && x.toString && x.toString() === \"true\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    const alts = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      TRUE,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isString(x)) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: any): boolean => {\n  if (x && x.toString && x.toString() === \"false\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\nconst isDate = (x: any): boolean => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (isString(x)) {\n    x = x.trim();\n\n    if (!x) {\n      return false;\n    }\n  }\n\n  if (isBoolean(x)) {\n    return false;\n  }\n\n  if (isArray(x) || isSet(x)) {\n    return false;\n  }\n\n  const y = date.parse(x);\n  return !!y;\n};\n\nconst isError = (x: any, errorLike=false): boolean => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  if (x instanceof Error) {\n    return true;\n  }\n\n  if (errorLike && x && x.stack && x.message) {\n    return true;\n  }\n\n  return false;\n};\n\n// @exports\nexport default {\n  isNil,\n  isNumber,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n  isDate,\n  isError,\n};\n", "import * as sorted from \"./sorted\";\n\nexport default {\n  ...sorted,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * program: \"patienceDiff\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiff( aLines[], bLines[], diffPlusFlag )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *      diffPlusFlag if true, returns additional arrays with the subset of lines that were\n *          either deleted or inserted.  These additional arrays are used by patienceDiffPlus.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLines[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is 0. (Only set when using patienceDiffPlus.)\n *\n */\n\nfunction patienceDiff(aLines: string[], bLines: string[], diffPlusFlag?: boolean) {\n\n  //\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n  // function is used in preparation for determining the longest common\n  // subsequence.  Specifically, it first reduces the array range in question\n  // to unique values.\n  //\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\n  // array index i as the Map value.\n  //\n\n  function findUnique(arr: string[], lo: number, hi: number) {\n\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n\n      const line = arr[i];\n\n      if (lineMap.has(line)) {\n\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n\n      } else {\n\n        lineMap.set(line, {\n          count: 1,\n          index: i\n        });\n\n      }\n\n    }\n\n    lineMap.forEach((val, key, map) => {\n\n      if (val.count !== 1) {\n\n        map.delete(key);\n\n      } else {\n\n        map.set(key, val.index);\n\n      }\n\n    });\n\n    return lineMap;\n\n  }\n\n  //\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n  // down the aArray and bArray ranges first, before then walking the comparison\n  // between the two arrays.\n  //\n  // Returns an ordered Map, with the Map key as the common line between aArray\n  // and bArray, with the Map value as an object containing the array indexes of\n  // the matching unique lines.\n  //\n\n  function uniqueCommon(aArray: string[], aLo: number, aHi: number, bArray: string[], bLo: number, bHi: number) {\n\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key, map) => {\n\n      if (mb.has(key)) {\n\n        map.set(key, {\n          indexA: val,\n          indexB: mb.get(key)\n        });\n\n      } else {\n\n        map.delete(key);\n\n      }\n\n    });\n\n    return ma;\n\n  }\n\n    type LCSResult = {\n        line: string,\n        aIndex: number,\n        bIndex: number,\n        moved?: boolean,\n    };\n\n    //\n    // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n    // and determines the Longest Common Subsequence (LCS).\n    //\n    // Returns an ordered array of objects containing the array indexes of the\n    // matching lines for a LCS.\n    //\n\n    function longestCommonSubsequence(abMap: Map<string, any>) {\n\n      const ja: any[] = [];\n\n      // First, walk the list creating the jagged array.\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      abMap.forEach((val, _key, _map) => {\n\n        let i = 0;\n\n        while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n\n          i++;\n\n        }\n\n        if (!ja[i]) {\n\n          ja[i] = [];\n\n        }\n\n        if (0 < i) {\n\n          val.prev = ja[i - 1][ja[i - 1].length - 1];\n\n        }\n\n        ja[i].push(val);\n\n      });\n\n      // Now, pull out the longest common subsequence.\n\n      let lcs: any[] = [];\n\n      if (0 < ja.length) {\n\n        const n = ja.length - 1;\n        lcs = [ja[n][ja[n].length - 1]];\n\n        while (lcs[lcs.length - 1].prev) {\n\n          lcs.push(lcs[lcs.length - 1].prev);\n\n        }\n\n      }\n\n      return lcs.reverse();\n\n    }\n\n    // \"result\" is the array used to accumulate the aLines that are deleted, the\n    // lines that are shared between aLines and bLines, and the bLines that were\n    // inserted.\n\n    const result: LCSResult[] = [];\n    let deleted = 0;\n    let inserted = 0;\n\n    // aMove and bMove will contain the lines that don't match, and will be returned\n    // for possible searching of lines that moved.\n\n    const aMove: string[] = [];\n    const aMoveIndex: number[] = [];\n    const bMove: string[] = [];\n    const bMoveIndex: number[] = [];\n\n    //\n    // addToResult simply pushes the latest value onto the \"result\" array.  This\n    // array captures the diff of the line, aIndex, and bIndex from the aLines\n    // and bLines array.\n    //\n\n    function addToResult(aIndex: number, bIndex: number) {\n\n      if (bIndex < 0) {\n\n        aMove.push(aLines[aIndex]);\n        aMoveIndex.push(result.length);\n        deleted++;\n\n      } else if (aIndex < 0) {\n\n        bMove.push(bLines[bIndex]);\n        bMoveIndex.push(result.length);\n        inserted++;\n\n      }\n\n      result.push({\n        line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n        aIndex,\n        bIndex,\n      });\n\n    }\n\n    //\n    // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n    // this function might recursively call recurseLCS to further match the lines\n    // between aLines and bLines.\n    //\n\n    function addSubMatch(aLo: number, aHi: number, bLo: number, bHi: number) {\n\n      // Match any lines at the beginning of aLines and bLines.\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n\n        addToResult(aLo++, bLo++);\n\n      }\n\n      // Match any lines at the end of aLines and bLines, but don't place them\n      // in the \"result\" array just yet, as the lines between these matches at\n      // the beginning and the end need to be analyzed first.\n\n      const aHiTemp = aHi;\n\n      while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n\n        aHi--;\n        bHi--;\n\n      }\n\n      // Now, check to determine with the remaining lines in the subsequence\n      // whether there are any unique common lines between aLines and bLines.\n      //\n      // If not, add the subsequence to the result (all aLines having been\n      // deleted, and all bLines having been inserted).\n      //\n      // If there are unique common lines between aLines and bLines, then let's\n      // recursively perform the patience diff on the subsequence.\n\n      const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n      if (uniqueCommonMap.size === 0) {\n\n        while (aLo <= aHi) {\n\n          addToResult(aLo++, - 1);\n\n        }\n\n        while (bLo <= bHi) {\n\n          addToResult(- 1, bLo++);\n\n        }\n\n      } else {\n\n        recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n\n      }\n\n      // Finally, let's add the matches at the end to the result.\n\n      while (aHi < aHiTemp) {\n\n        addToResult(++aHi, ++bHi);\n\n      }\n\n    }\n\n    //\n    // recurseLCS finds the longest common subsequence (LCS) between the arrays\n    // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n    // recursively performs another LCS search (via addSubMatch), until there are\n    // none found, at which point the subsequence is dumped to the result.\n    //\n\n    function recurseLCS(aLo: number, aHi: number, bLo: number, bHi: number, uniqueCommonMap?: Map<string, any>) {\n\n      const x = longestCommonSubsequence(uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi));\n\n      if (x.length === 0) {\n\n        addSubMatch(aLo, aHi, bLo, bHi);\n\n      } else {\n\n        if (aLo < x[0].indexA || bLo < x[0].indexB) {\n\n          addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n\n        }\n\n        let i;\n        for (i = 0; i < x.length - 1; i++) {\n\n          addSubMatch(x[i].indexA, x[i + 1].indexA - 1, x[i].indexB, x[i + 1].indexB - 1);\n\n        }\n\n        if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n\n          addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n\n        }\n\n      }\n\n    }\n\n    recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n    if (diffPlusFlag) {\n\n      return {\n        lines: result,\n        lineCountDeleted: deleted,\n        lineCountInserted: inserted,\n        lineCountMoved: 0,\n        aMove,\n        aMoveIndex,\n        bMove,\n        bMoveIndex,\n      };\n\n    }\n\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n    };\n\n}\n\n/**\n * program: \"patienceDiffPlus\" algorithm implemented in javascript.\n * author: Jonathan Trent\n * version: 2.0\n *\n * use:  patienceDiffPlus( aLines[], bLines[] )\n *\n * where:\n *      aLines[] contains the original text lines.\n *      bLines[] contains the new text lines.\n *\n * returns an object with the following properties:\n *      lines[] with properties of:\n *          line containing the line of text from aLines or bLines.\n *          aIndex referencing the index in aLine[].\n *          bIndex referencing the index in bLines[].\n *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex\n *               referencing the original index. If aIndex === -1 then the line is new from bLines,\n *               and if bIndex === -1 then the line is old from aLines.)\n *          moved is true if the line was moved from elsewhere in aLines[] or bLines[].\n *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].\n *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].\n *      lineCountMoved is the number of lines that moved.\n *\n */\n\n// function patienceDiffPlus(aLines: string[], bLines: string[]) {\n\n//   const difference = patienceDiff(aLines, bLines, true);\n\n//   let aMoveNext = difference.aMove || [];\n//   let aMoveIndexNext = difference.aMoveIndex || [];\n//   let bMoveNext = difference.bMove || [];\n//   let bMoveIndexNext = difference.bMoveIndex || [];\n\n//   delete difference.aMove;\n//   delete difference.aMoveIndex;\n//   delete difference.bMove;\n//   delete difference.bMoveIndex;\n\n//   let lastLineCountMoved;\n\n//   do {\n\n//     const aMove = aMoveNext;\n//     const aMoveIndex = aMoveIndexNext;\n//     const bMove = bMoveNext;\n//     const bMoveIndex = bMoveIndexNext;\n\n//     aMoveNext = [];\n//     aMoveIndexNext = [];\n//     bMoveNext = [];\n//     bMoveIndexNext = [];\n\n//     const subDiff = patienceDiff(aMove, bMove, false);\n\n//     lastLineCountMoved = difference.lineCountMoved;\n\n//     subDiff.lines.forEach((v, i) => {\n\n//       if (0 <= v.aIndex && 0 <= v.bIndex) {\n\n//         difference.lines[aMoveIndex[v.aIndex]].moved = true;\n//         difference.lines[bMoveIndex[v.bIndex]].aIndex = aMoveIndex[v.aIndex];\n//         difference.lines[bMoveIndex[v.bIndex]].moved = true;\n//         difference.lineCountInserted--;\n//         difference.lineCountDeleted--;\n//         difference.lineCountMoved++;\n\n//       } else if (v.bIndex < 0) {\n\n//         aMoveNext.push(aMove[v.aIndex]);\n//         aMoveIndexNext.push(aMoveIndex[v.aIndex]);\n\n//       } else {\n\n//         bMoveNext.push(bMove[v.bIndex]);\n//         bMoveIndexNext.push(bMoveIndex[v.bIndex]);\n\n//       }\n\n//     });\n\n//   } while (0 < difference.lineCountMoved - lastLineCountMoved);\n\n//   return difference;\n\n// }\n\nconst ___IGNORE = patienceDiff([], [], true);\nexport type PatienceDiffResult = typeof ___IGNORE;\n\nexport type ChangeType = \"deleted\" | \"inserted\" | \"changed\" | \"unknown\";\n\nexport type Change = {\n    lineNumber: number,\n    changeType: ChangeType,\n    lineContent: string,\n    aIndex: number,\n    bIndex: number,\n};\n\nexport type DiffResult = {\n    changes: Change[],\n    deletedCount: number,\n    insertedCount: number,\n    movedCount: number,\n    linedMovedFromA: string[],\n    linesMovedFromB: string[],\n    _diff: PatienceDiffResult,\n};\n\nconst compare = (a: string, b: string): DiffResult => {\n  const desc = patienceDiff(a.split(\"\\n\"), b.split(\"\\n\"), true);\n\n  const changes: Change[] = desc.lines.map((line, index) => {\n    let changeType: ChangeType = \"unknown\";\n    if (line.aIndex >= 0 && line.bIndex < 0) {\n      changeType = \"deleted\";\n    } else if (line.aIndex < 0 && line.bIndex >= 0) {\n      changeType = \"inserted\";\n    } else if (line.aIndex >= 0 && line.bIndex >= 0) {\n      changeType = \"changed\";\n    }\n\n    return {\n      changeType,\n      lineNumber: index + 1,\n      lineContent: line.line,\n      aIndex: line.aIndex,\n      bIndex: line.bIndex,\n    };\n  });\n\n  return {\n    changes,\n    deletedCount: desc.lineCountDeleted,\n    insertedCount: desc.lineCountInserted,\n    movedCount: desc.lineCountInserted,\n    linedMovedFromA: desc.aMove || [],\n    linesMovedFromB: desc.bMove || [],\n    _diff: desc,\n  };\n};\n\nexport default {\n  compare,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM),\n// which is licensed under the MIT License.\n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport { type AnyFn } from \"../@types\";\nimport check from \"../check\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n\n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}, warnings: string[] = []): any => {\n  console.assert(check.isObject(expr));\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\")) {\n        warnings.push(\"Unknown variable '\" + value + \"'\");\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\")) {\n      warnings.push(\"Unknown function '\" + name + \"'\");\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, Lexer, parseExpr, runExpr } from \"./eval\";\nimport { AnyFn, type TypeOf } from \"../@types\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nconst builtinFunctions = () => {\n  const $abs = (x: any): number => Math.abs(x);\n  const $all = (...args: any[]): boolean => {\n    return args.map($bool).every((x) => x === true);\n  };\n  const $any = (...args: any[]): boolean => {\n    return args.map($bool).some((x) => x === true);\n  };\n\n  const $bool = (x: any): boolean => {\n    if (check.isValidBoolean(x)) {\n      return check.isTrue(x);\n    }\n\n    return !!x && $isset(x);\n  };\n  const $float = (x: any): number => parseFloat(x);\n  const $str = (x: any): string => {\n    if (check.isObject(x)) {\n      x = JSON.stringify(x, null, 0);\n    }\n\n    if (!check.isString(x)) {\n      x = x.toString ? x.toString() : `${x}`;\n    }\n\n    return x;\n  };\n\n  const $format = (fmt: string, ...args: any[]): string => {\n    if (!check.isString(fmt) || args.length === 0) {\n      return fmt;\n    }\n    args.map($str).forEach((variable, index) => {\n      const template = `{${index}}`;\n      while (fmt.includes(template)) {\n        fmt = fmt.replace(template, variable);\n      }\n    });\n\n    return fmt;\n  };\n\n  // const $hash = (x: string): number => {\n  //   x = $str(x);\n  //   let hash = 0;\n  //   for (let i = 0; i < x.length; ++i) {\n  //     const code = x.charCodeAt(i);\n  //     hash = ((hash << 5) - hash) + code;\n  //     hash &= hash;\n  //   }\n  //   return hash;\n  // };\n\n  const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n    return $bool(condition) ? ifTrue : ifFalse;\n  };\n\n  const $int = (x: any): number => parseInt(x);\n  const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n    const xType = $type(x);\n    return types.map($str).some((t) => xType === t);\n  };\n\n  const $tisstring = (x: any) => {\n    return $isinstance(x, \"string\");\n  };\n  const $tisnumber = (x: any) => {\n    return $isinstance(x, \"number\", \"bigint\");\n  };\n  const $tisundefined = (x: any) => {\n    return $isinstance(x, \"undefined\");\n  };\n  const $tisobject = (x: any) => {\n    return $isinstance(x, \"object\");\n  };\n  const $tisboolean = (x: any) => {\n    return $isinstance(x, \"boolean\");\n  };\n  const $isnil = (x: any) => {\n    return x === null || x === undefined;\n  };\n\n  const $endsWith = (x: any, searchString: string, endPos?: number) => {\n    x = $str(x);\n    searchString = $str(searchString);\n    return x.endsWith(searchString, endPos);\n  };\n  const $startsWith = (x: any, searchString: string, pos?: number) => {\n    return $str(x).startsWith(searchString, pos);\n  };\n  const $lower = (x: any) => {\n    return $str(x).toLowerCase();\n\n  };\n  const $upper = (x: any) => {\n    return $str(x).toUpperCase();\n  };\n\n  const $len = (x: any): number => {\n    return $str(x).length;\n  };\n\n  const $max = (...args: any[]): any => {\n    return Math.max(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n  const $min = (...args: any[]): any => {\n    return Math.min(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n\n  const $pow = (a: number, b: number) => Math.pow(a, b);\n  const $round = (a: number) => Math.round(a);\n  const $math = (key: string, ...args: any[]) => {\n    try {\n      const intrinsic = (Math as any)[key];\n      const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n      if (result) {\n        return result;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    const argv = args.join(\", \");\n    return `Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`;\n  };\n  const $concat = (...args: any[]) => {\n    return args.map($str).join(\"\");\n  };\n  const $substring = (x: string, start: number, end?: number) => {\n    const str = $str(x);\n    if (start === undefined || !check.isNumber(start) || start < 0) {\n      start = 0;\n    }\n    if (end === undefined || !check.isNumber(start) || end > str.length) {\n      end = str.length;\n    }\n    return str.substring(start, end);\n\n  };\n  const $type = (x: any) => typeof x;\n  const $getattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          }\n        });\n    });\n\n\n    return ptr;\n  };\n\n  const $hasattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    let result = true;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back\n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n\n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          } else {\n            result = false;\n          }\n        });\n    });\n\n\n    return result;\n  };\n  const $isset = (obj: any) => {\n    return !$str(obj).startsWith(\"$\");\n  };\n\n  const $includes = (x: any, value: any) => {\n    if (x) {\n      if (x.includes && check.isFunction(x.includes)) {\n        return x.includes(value);\n      }\n\n      if (x.has && check.isFunction(x.has)) {\n        return x.has(value);\n      }\n    }\n\n    return false;\n  };\n\n  const $now = () => {\n    return new Date();\n  };\n\n  return {\n    $if,\n    $abs,\n    $all,\n    $any,\n    $bool,\n    $float,\n    $str,\n    $format,\n    $int,\n    $isnil,\n    $isinstance,\n    $tisstring,\n    $tisnumber,\n    $tisboolean,\n    $tisundefined,\n    $tisobject,\n    $len,\n    $max,\n    $min,\n    $pow,\n    $round,\n    $substring,\n    $type,\n    $math,\n    $getattr,\n    $concat,\n    $hasattr,\n    $isset,\n    $includes,\n    $endsWith,\n    $startsWith,\n    $lower,\n    $upper,\n    $now,\n  };\n};\n\n\ntype ParseError = {\n  lineNumber: number,\n  message: string,\n  error: Error,\n};\n\ntype ParseWarning = {\n  lineNumber: number,\n  message: string,\n};\n/**\n *\n * @param sentence sentence\n * @param _ctx context\n * @returns evaludated sentence\n *\n * @deprecated use `class SentenceParser`\n */\nconst parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  const warnings: ParseWarning[] = [];\n  const errors: ParseError[] = [];\n  const result = sentence\n    .split(\"\\n\")\n    .map((line, index) => {\n      try {\n        const parsed = _parseSentence(line , _ctx);\n        warnings.push(...parsed.warnings.map((message) => ({\n          lineNumber: index + 1,\n          message,\n        })));\n\n        return parsed.result;\n      } catch(error: any) {\n        let message = \"\";\n\n        if (error) {\n          message = error.message;\n          if (!message && error.toString) {\n            message = error.toString();\n          }\n        }\n\n        errors.push({\n          lineNumber: index + 1,\n          message,\n          error,\n        });\n      }\n\n      return line;\n    })\n    .join(\"\\n\");\n  return {\n    result,\n    warnings,\n    errors,\n  };\n};\n\nconst _parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  const warnings: string[] = [];\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      while (word && (isPeriod || isExcla)) {\n        word = word.substring(0, word.length - 1);\n\n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }\n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx, /*&mut*/warnings);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n\n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && ![\"!\", \".\", \",\"].includes(lex.nextToken() as string)) {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return {\n    result: builder.join(\"\").trim(),\n    warnings,\n  };\n};\n\nexport type BuiltInFunction = ReturnType<typeof builtinFunctions>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\nexport type Context = EvalContext;\nexport type SentenceParserOptions = {\n  includeBuiltIns: boolean,\n};\nclass SentenceParser {\n  constructor(\n    public options: SentenceParserOptions = {\n      includeBuiltIns: true,\n    },\n    public ctx: Context = {},\n  ) {\n\n    if (this.options.includeBuiltIns) {\n      this.ctx.funcs = {\n        ...builtinFunctions(),\n        ...(this.ctx.funcs || {}),\n      };\n    }\n  }\n\n  fixName(name: string) {\n    return name.startsWith(\"$\") ? name : \"$\" + name;\n  }\n\n  fnExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.funcs || {});\n  }\n\n  varExists(name: string): boolean {\n    name = this.fixName(name);\n    return name in (this.ctx.vars || {});\n  }\n\n  addVar(name: string, value: any) {\n    name = this.fixName(name);\n    this.ctx.vars = this.ctx.vars || {};\n    this.ctx.vars[name] = value;\n  }\n\n  addFunction(name: string, cb: AnyFn) {\n    name = this.fixName(name);\n    this.ctx.funcs = this.ctx.funcs || {};\n    this.ctx.funcs[name] = cb;\n  }\n\n  parse(sentence: string) {\n    return parseSentence(sentence, this.ctx || {});\n  }\n\n}\n\nexport default {\n  SentenceParser,\n  builtinFunctions,\n  parseSentence,\n};\n", "import { ReverseSortedArray } from \"../array/sorted\";\n\n\n/**\n * Compares the similarity between two strings using an n-gram comparison method.\n * The grams default to length 2.\n * @param str1 The first string to compare.\n * @param str2 The second string to compare.\n * @param gramSize The size of the grams. Defaults to length 2.\n */\nconst similarity = (str1: string, str2: string, gramSize = 2) => {\n  const getNGrams = (s: string, len: number) => {\n    s = \" \".repeat(len - 1) + s.toLowerCase() + \" \".repeat(len - 1);\n    const v = new Array(s.length - len + 1);\n    for (let i = 0; i < v.length; i++) {\n      v[i] = s.slice(i, i + len);\n    }\n    return v;\n  };\n\n  if (!str1?.length || !str2?.length) { return 0.0; }\n\n  // Order the strings by length so the order they're passed in doesn't matter\n  // and so the smaller string's ngrams are always the ones in the set\n  const s1 = str1.length < str2.length ? str1 : str2;\n  const s2 = str1.length < str2.length ? str2 : str1;\n\n  const pairs1 = getNGrams(s1, gramSize);\n  const pairs2 = getNGrams(s2, gramSize);\n  const set = new Set<string>(pairs1);\n\n  const total = pairs2.length;\n  let hits = 0;\n  for (const item of pairs2) {\n    if (set.delete(item)) {\n      hits++;\n    }\n  }\n  return hits / total;\n};\n\n/**\n *\n * Sorts an array in place based on similarity. This method mutates the array and returns a reference to the same array.\n * @param value string that will be used to compare similarity\n * @param topK return top k matches\n * @param gramSize The size of the grams. Defaults to length 2.\n * @param values array to sort\n * @param key Function used to get the value to sort by\n * @returns a reference to the same array which was sorted in place.\n */\nconst topSimilar = <T = string>(value: T, values: T[], key: (obj: T) => string, topK = 5, gramSize = 2) => {\n  const str1 = key(value);\n  if (topK <= 0) {\n    topK = 5;\n  }\n\n  const arr = new ReverseSortedArray((x: T) => similarity(str1, key(x), gramSize));\n  values.forEach((x) => {\n    arr.push(x);\n\n    if (arr.length > topK) {\n      arr.pop();\n    }\n  });\n\n  return [...arr];\n};\n\nexport default {\n  similarity,\n  topSimilar,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport check from \"../check\";\n\nconst hashCode = (str: any, coerceToString = true): number | null => {\n\n  if (coerceToString) {\n    if (!check.isString(str)) {\n      if (check.isSet(str)) {\n        str = Array.from(str);\n      }\n\n      if (check.isObject(str)) {\n        try {\n          str = JSON.stringify(str);\n        } catch (ignored) {\n          const circularReference: any[] = [];\n          const jsonString = JSON.stringify(str, (key, value) => {\n            if (typeof value === \"object\" && value !== null) {\n              if (circularReference.includes(value)) {\n                return \"[Circular]\";\n              }\n              circularReference.push(value);\n            }\n            return value;\n          });\n\n          // Replace circular references with actual object reference\n          str = jsonString.replace(/\"\\[Circular\\]\"/g, () => {\n            return JSON.stringify(\"[Circular]\");\n          });\n        }\n      }\n\n      if (!check.isString(str) && str.toString) {\n        str = str.toString();\n      }\n    }\n  }\n\n  if (!check.isString(str)) {\n    return null;\n  }\n\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nconst capitalize = (str: string) => {\n  if (!check.isString(str)) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport default {\n  hashCode,\n  capitalize,\n};", "\n// This code is a port of (i.e., based on) the inflection project (https://github.com/jpvanhal/inflection),\n// which is licensed under the MIT License.\n// Copyright (C) 2012-2020 Janne Vanhala\n\nimport utils from \"../utils\";\n\n\nexport type RegexReplaceList = [RegExp, string][]\n\nconst PLURALS: RegexReplaceList = [\n  [/(quiz)$/i, \"$1zes\"],\n  [/^(oxen)$/i, \"$1\"],\n  [/^(ox)$/i, \"$1en\"],\n  [/(m|l)ice$/i, \"$1ice\"],\n  [/(m|l)ouse$/i, \"$1ice\"],\n  [/(passer)s?by$/i, \"$1sby\"],\n  [/(matr|vert|ind)(?:ix|ex)$/i, \"$1ices\"],\n  [/(x|ch|ss|sh)$/i, \"$1es\"],\n  [/([^aeiouy]|qu)y$/i, \"$1ies\"],\n  [/(hive)$/i, \"$1s\"],\n  [/([lr])f$/i, \"$1ves\"],\n  [/([^f])fe$/i, \"$1ves\"],\n  [/sis$/i, \"ses\"],\n  [/([ti])a$/i, \"$1a\"],\n  [/([ti])um$/i, \"$1a\"],\n  [/(buffal|potat|tomat)o$/i, \"$1oes\"],\n  [/(bu)s$/i, \"$1ses\"],\n  [/(alias|status)$/i, \"$1es\"],\n  [/(octop|vir)i$/i, \"$1i\"],\n  [/(octop|vir)us$/i, \"$1i\"],\n  [/^(ax|test)is$/i, \"$1es\"],\n  [/s$/i, \"s\"],\n  [/$/i, \"s\"],\n];\n\nconst SINGULARS: RegexReplaceList = [\n  [/(database)s$/i, \"$1\"],\n  [/(quiz)zes$/i, \"$1\"],\n  [/(matr)ices$/i, \"$1ix\"],\n  [/(vert|ind)ices$/i, \"$1ex\"],\n  [/(passer)sby$/i, \"$1by\"],\n  [/^(ox)en/i, \"$1\"],\n  [/(alias|status)(es)?$/i, \"$1\"],\n  [/(octop|vir)(us|i)$/i, \"$1us\"],\n  [/^(a)x[ie]s$/i, \"$1xis\"],\n  [/(cris|test)(is|es)$/i, \"$1is\"],\n  [/(shoe)s$/i, \"$1\"],\n  [/(o)es$/i, \"$1\"],\n  [/(bus)(es)?$/i, \"$1\"],\n  [/(m|l)ice$/i, \"$1ouse\"],\n  [/(x|ch|ss|sh)es$/i, \"$1\"],\n  [/(m)ovies$/i, \"$1ovie\"],\n  [/(s)eries$/i, \"$1eries\"],\n  [/([^aeiouy]|qu)ies$/i, \"$1y\"],\n  [/([lr])ves$/i, \"$1f\"],\n  [/(tive)s$/i, \"$1\"],\n  [/(hive)s$/i, \"$1\"],\n  [/([^f])ves$/i, \"$1fe\"],\n  [/(t)he(sis|ses)$/i, \"$1hesis\"],\n  [/(s)ynop(sis|ses)$/i, \"$1ynopsis\"],\n  [/(p)rogno(sis|ses)$/i, \"$1rognosis\"],\n  [/(p)arenthe(sis|ses)$/i, \"$1arenthesis\"],\n  [/(d)iagno(sis|ses)$/i, \"$1iagnosis\"],\n  [/(b)a(sis|ses)$/i, \"$1asis\"],\n  [/(a)naly(sis|ses)$/i, \"$1nalysis\"],\n  [/([ti])a$/i, \"$1um\"],\n  [/(n)ews$/i, \"$1ews\"],\n  [/(ss)$/i, \"$1\"],\n  [/s$/i, \"\"],\n];\n\nconst UNCOUNTABLES = new Set([\n  \"equipment\",\n  \"fish\",\n  \"information\",\n  \"jeans\",\n  \"money\",\n  \"rice\",\n  \"series\",\n  \"sheep\",\n  \"species\",\n]);\n\n\n/**\n\nA convenience function to add appropriate rules to plurals and singular\nfor irregular words.\n\n@param singular: irregular word in singular form\n@param plural: irregular word in plural form\n */\nconst _irregular = (singular: string, plural: string): void => {\n  const caseinsensitive = (x: string): string => {\n    return Array\n      .from(x)\n      .map((char) => \"[\" + char + char.toUpperCase() + \"]\")\n      .join(\"\");\n  };\n\n  const insert = (arr: RegexReplaceList, index: number, elem: [string, string]) => {\n    arr.splice(index, 0, [new RegExp(elem[0], \"i\"), elem[1]]);\n  };\n\n  const pluralInsert = (index: number, elem: [string, string]) => {\n    insert(PLURALS, index, elem);\n  };\n\n  const singularInsert = (index: number, elem: [string, string]) => {\n    insert(SINGULARS, index, elem);\n  };\n\n  if (singular[0].toUpperCase() == plural[0].toUpperCase()) {\n    pluralInsert(0, [\n      `(${singular[0]})${singular.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `(${plural[0]})${plural.slice(1)}$`,\n      \"$1\" + singular.slice(1)\n    ]);\n  } else {\n    pluralInsert(0, [\n      `${singular[0].toUpperCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${singular[0].toLowerCase()}${caseinsensitive(singular.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toUpperCase() + plural.slice(1)\n    ]);\n    pluralInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      plural[0].toLowerCase() + plural.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toUpperCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toUpperCase() + singular.slice(1)\n    ]);\n    singularInsert(0, [\n      `${plural[0].toLowerCase()}${caseinsensitive(plural.slice(1))}$`,\n      singular[0].toLowerCase() + singular.slice(1)\n    ]);\n  }\n};\n\nconst camelize = (string: string, uppercaseFirstLetter = true): string => {\n  const camelCase = dasherize(string)\n    .replace(/-/, \" \")\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(word, index) {\n      return index === 0 ? word.toLowerCase() : word.toUpperCase();\n    })\n    .replace(/\\s+/g, \"\");\n\n  const result = uppercaseFirstLetter\n    ? camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\n    : camelCase;\n\n  return result;\n};\n\nfunction dasherize(word: string): string {\n  // Replace underscores with dashes in the string.\n  // Example: dasherize(\"puni_puni\") returns 'puni-puni'\n  return word.replace(/_/g, \"-\");\n}\n\nfunction humanize(word: string): string {\n  /*\n    Capitalize the first word and turn underscores into spaces and strip a\n    trailing \"_id\", if any. Like titleize, this is meant for creating pretty output.\n\n    Examples:\n\n    >>> humanize(\"employee_salary\")\n    'Employee salary'\n    >>> humanize(\"author_id\")\n    'Author'\n    */\n\n  word = word.replace(/_id$/i, \"\");\n  word = word.replace(/_/g, \" \");\n  word = word.replace(/([a-z\\d]*)/g, function (m) {\n    return m.toLowerCase();\n  });\n  word = word.replace(/^\\w/, function (m) {\n    return m.toUpperCase();\n  });\n  return word;\n}\n\nfunction ordinal(number: string): string {\n  /*\n    Return the suffix that should be added to a number to denote the position\n    in an ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n    >>> ordinal(1)\n    'st'\n    >>> ordinal(2)\n    'nd'\n    >>> ordinal(1002)\n    'nd'\n    >>> ordinal(1003)\n    'rd'\n    >>> ordinal(-11)\n    'th'\n    >>> ordinal(-1021)\n    'st'\n    */\n\n  const n = Math.abs(parseInt(number));\n  if ([11, 12, 13].includes(n % 100)) {\n    return \"th\";\n  } else {\n    switch (n % 10) {\n    case 1:\n      return \"st\";\n    case 2:\n      return \"nd\";\n    case 3:\n      return \"rd\";\n    default:\n      return \"th\";\n    }\n  }\n}\n\nfunction ordinalize(number: string) {\n  /*\n    Turn a number into an ordinal string used to denote the position in an\n    ordered sequence such as 1st, 2nd, 3rd, 4th.\n\n    Examples:\n\n    >>> ordinalize(1)\n    '1st'\n    >>> ordinalize(2)\n    '2nd'\n    >>> ordinalize(1002)\n    '1002nd'\n    >>> ordinalize(1003)\n    '1003rd'\n    >>> ordinalize(-11)\n    '-11th'\n    >>> ordinalize(-1021)\n    '-1021st'\n    */\n\n  return number + ordinal(number);\n}\n\nconst parameterize = (string: string, separator = \"-\") => {\n  const cleaned = transliterate(string);\n  let param = cleaned.replace(/[^\\d\\w-]+/gmi, separator);\n  if (separator !== \"\") {\n    while (param.startsWith(separator)) {\n      param = param.slice(separator.length);\n    }\n\n    while (param.endsWith(separator)) {\n      param = param.slice(0, param.length - separator.length);\n    }\n  }\n  return param.toLowerCase();\n};\n\nconst pluralize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  const endsWithLetter = /[A-Za-z]$/.test(word);\n  if (!word || UNCOUNTABLES.has(word.toLowerCase()) || !endsWithLetter) {\n    return word;\n  }\n\n  for (const elem of PLURALS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n\n  return word;\n};\n\nconst singularize = (word: string) => {\n  const isUpper = /[A-Z]/.test(word.charAt(0));\n  for (const u of UNCOUNTABLES) {\n    const regex = new RegExp(`\\\\b${u}\\\\b`, \"i\");\n    if (regex.test(word)) {\n      return word;\n    }\n  }\n\n  for (const elem of SINGULARS) {\n    const rule = elem[0];\n    const replacement = elem[1];\n    if (rule.test(word)) {\n      const result = word.replace(rule, replacement);\n      return isUpper ? utils.capitalize(result) : result;\n    }\n  }\n  return word;\n};\n\nconst tableize = (word: string): string => {\n  return pluralize(underscore(word));\n};\n\nfunction titleize(word: string) {\n  return humanize(underscore(word))\n    .split(/\\s+/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n}\n\n\nfunction transliterate(string: string) {\n  const normalized = string.normalize(\"NFKD\");\n  return normalized\n    .replace(/[\\u0300-\\u036f]/g, \"\") // remove combining diacritical marks\n    // eslint-disable-next-line no-control-regex\n    .replace(/[^\\x00-\\x7F]/g, \"\") // remove non-ASCII characters\n    .trim();\n}\n\nfunction underscore(word: string) {\n  let underscored = word.replace(/([a-z\\d])([A-Z])/g, \"$1_$2\"); // split camelCase\n  underscored = underscored.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\"); // split PascalCase\n  underscored = underscored.replace(/-/g, \"_\"); // replace hyphens with underscores\n  return underscored.toLowerCase();\n}\n\n_irregular(\"person\", \"people\");\n_irregular(\"man\", \"men\");\n_irregular(\"human\", \"humans\");\n_irregular(\"child\", \"children\");\n_irregular(\"sex\", \"sexes\");\n_irregular(\"move\", \"moves\");\n_irregular(\"cow\", \"kine\");\n_irregular(\"zombie\", \"zombies\");\n_irregular(\"slave\", \"slaves\");\n_irregular(\"this\", \"this\");\n_irregular(\"flour\", \"flour\");\n_irregular(\"milk\", \"milk\");\n_irregular(\"water\", \"water\");\n_irregular(\"reserve\", \"reserves\");\n_irregular(\"gas\", \"gasses\");\n_irregular(\"bias\", \"biases\");\n_irregular(\"atlas\", \"atlases\");\n_irregular(\"goose\", \"geese\");\n_irregular(\"pasta\", \"pastas\");\n_irregular(\"slice\", \"slices\");\n_irregular(\"cactus\", \"cacti\");\n\nexport default {\n  camelize,\n  dasherize,\n  humanize,\n  ordinal,\n  ordinalize,\n  parameterize,\n  pluralize,\n  singularize,\n  tableize,\n  titleize,\n  transliterate,\n  underscore,\n\n  UNCOUNTABLES,\n  PLURALS,\n  SINGULARS,\n};", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\n\nconst isError = (x: any) => {\n  return check.isError(x, /*error like = */ false);\n};\n\nexport class Option<T> {\n\n}\n\nexport class Result<\n    TReturn,\n    E = Error,\n    // Fix any[] inferr from input\n    Fn extends (...any: any[]) => TReturn = (...any: any[]) => TReturn,\n    FnArgs extends any[] = Parameters<Fn>,\n> {\n  constructor(\n        public fn: Fn,\n        public result?: TReturn,\n        public error?: E,\n        public ran: boolean = false\n  ) {\n  }\n\n  match(callbacks: {\n        onOk: (result: TReturn) => void,\n        onError: (error: E) => void,\n        /** this will be called when both result and error are undefined */\n        debug?: (result?: TReturn, error?: E) => void,\n    }): [TReturn | undefined, E | undefined] {\n\n    const isErr = this.isErr();\n    const isOk = this.isOk();\n\n    if (isErr === null && isOk === null && callbacks.debug) {\n      callbacks.debug(this.result, this.error);\n    }\n\n    if (isOk && this.result !== undefined) {\n      callbacks.onOk(this.result);\n    } else if (isErr && this.error !== undefined) {\n      callbacks.onError(this.error);\n    } else if (callbacks.debug) {\n      callbacks.debug(this.result, this.error);\n    }\n\n    return [this.result, this.error];\n  }\n\n  run(...args: FnArgs) {\n    this.ran = true;\n\n    try {\n      const result = this.fn(...args);\n\n      if (isError(result)) {\n        // SAFETY: Checking if it is an instanceof Error\n        this.error = result as any;\n      } else {\n        this.result = result;\n      }\n\n    } catch (error: any) {\n      this.error = error;\n    }\n\n    return this;\n  }\n\n  isErr(): boolean | null {\n    if (!this.ran) {\n      return null;\n    }\n\n    const noError = this.error === undefined;\n    const noResult = this.result === undefined;\n    if (noResult && noError) {\n      return null;\n    }\n\n    if (noResult && !noError) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isOk(): boolean | null {\n    if (!this.ran) {\n      return null;\n    }\n\n    const noError = this.error === undefined;\n    const noResult = this.result === undefined;\n    if (noResult && noError) {\n      return null;\n    }\n\n    if (noError) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\n// const r = new Result<number, Error>(\n//   (a: number, b: number) => {\n//     return a + a * b;\n//   },\n// );\n\n// const [result, error] = r.run(1, 2).match({\n//   onOk: (a) => {\n//     //\n//   },\n//   onError: (a) => {\n//     //\n//   },\n// });\n\n\n\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "src_default", "types_exports", "sorted_exports", "__export", "BisectArray", "ReverseCompareArray", "ReverseNumberArray", "ReverseSortedArray", "ReverseStringArray", "SortedArray", "SortedCompareArray", "SortedNumberArray", "SortedStringArray", "subtractSeconds", "date", "seconds", "isWeekend", "day", "between", "startDate", "endDate", "parse", "input", "inputDate", "ignored", "date_default", "TRUE", "FALSE", "BOOLEANS", "isNumber", "x", "isString", "isBoolean", "isFunction", "isObject", "isNil", "isArray", "isSet", "isIterable", "isNumeric", "isValidBoolean", "isNum", "isStr", "alts", "len", "isTrue", "isFalse", "isDate", "date_default", "isError", "errorLike", "check_default", "BisectArray", "opts", "items", "a", "b", "item", "index", "left", "right", "mid", "keyA", "keyB", "check_default", "ReverseSortedArray", "key", "SortedArray", "ReverseNumberArray", "SortedNumberArray", "ReverseStringArray", "SortedStringArray", "ReverseCompareArray", "cmp", "SortedCompareArray", "array_default", "__spreadValues", "sorted_exports", "patienceDiff", "aLines", "bLines", "diffPlusFlag", "findUnique", "arr", "lo", "hi", "lineMap", "i", "line", "val", "key", "map", "uniqueCommon", "aArray", "aLo", "aHi", "bArray", "bLo", "bHi", "ma", "mb", "longestCommonSubsequence", "abMap", "ja", "_key", "_map", "lcs", "n", "result", "deleted", "inserted", "aMove", "aMoveIndex", "bMove", "bMoveIndex", "addToResult", "aIndex", "bIndex", "addSubMatch", "aHiTemp", "uniqueCommonMap", "recurseLCS", "x", "___IGNORE", "compare", "a", "b", "desc", "index", "changeType", "diff_default", "__SAVE", "BIN_PREC", "BINARY_OPS", "lhs", "rhs", "check_default", "UNARY_OPS", "arg", "Lexer", "src", "hist", "syntax", "alreadyCrashed", "token", "isTokenBreak", "c", "isDouble", "isSingle", "isSOFStr", "strEnd", "i", "valid", "spaceCount", "parsePrimary", "lexer", "operand", "parseExpr", "expr", "nextToken", "args", "prec", "opToken", "runExpr", "ctx", "warnings", "value", "number", "unary_op", "op", "binary_op", "funcall", "name", "_a", "params", "x", "fixString", "x", "check_default", "wrapCtxFuncs", "mut_ctx", "_f", "f", "__spreadValues", "updated", "k", "args", "builtinFunctions", "$abs", "$all", "$bool", "$any", "$isset", "$float", "$str", "$format", "fmt", "variable", "index", "template", "$if", "condition", "ifTrue", "ifFalse", "$int", "$isinstance", "types", "xType", "$type", "t", "$tisstring", "$tisnumber", "$tisundefined", "$tisobject", "$tisboolean", "$isnil", "$endsWith", "searchString", "endPos", "$startsWith", "pos", "$lower", "$upper", "$len", "$max", "$min", "$pow", "a", "b", "$round", "$math", "key", "intrinsic", "result", "error", "argv", "$concat", "$substring", "start", "end", "str", "$getattr", "obj", "path", "ptr", "literalKey", "keys", "$hasattr", "value", "parseSentence", "sentence", "_ctx", "warnings", "errors", "line", "parsed", "_parseSentence", "message", "_a", "ctx", "lex", "Lexer", "builder", "_restore", "restoreSpace", "expr", "parseExpr", "word", "cutHist", "isPeriod", "isExcla", "isFuncCall", "isSymbol", "resolved", "runExpr", "append", "isVar", "commaLoc", "SentenceParser", "options", "name", "cb", "eval_default", "similarity", "str1", "str2", "gramSize", "getNGrams", "s", "len", "v", "i", "s1", "s2", "pairs1", "pairs2", "set", "total", "hits", "item", "topSimilar", "value", "values", "key", "topK", "arr", "ReverseSortedArray", "x", "fuzzy_default", "hashCode", "str", "coerceToString", "check_default", "ignored", "circularReference", "key", "value", "hash", "i", "code", "capitalize", "utils_default", "PLURALS", "SINGULARS", "UNCOUNTABLES", "_irregular", "singular", "plural", "caseinsensitive", "x", "char", "insert", "arr", "index", "elem", "pluralInsert", "singularInsert", "camelize", "string", "uppercaseFirstLetter", "camelCase", "dasherize", "word", "humanize", "m", "ordinal", "number", "n", "ordinalize", "parameterize", "separator", "param", "transliterate", "pluralize", "isUpper", "endsWithLetter", "rule", "replacement", "result", "utils_default", "singularize", "u", "tableize", "underscore", "titleize", "underscored", "inflection_default", "std_exports", "__export", "Option", "Result", "isError", "x", "check_default", "Option", "Result", "fn", "result", "error", "ran", "callbacks", "isErr", "isOk", "args", "noError", "noResult", "src_default", "__spreadValues", "check_default", "eval_default", "inflection_default", "utils_default", "date_default", "fuzzy_default", "array_default", "diff_default", "std_exports", "types_exports"]
}
