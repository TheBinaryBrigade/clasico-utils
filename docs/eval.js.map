{
  "version": 3,
  "sources": ["../src/index.ts", "../src/check/index.ts", "../src/eval/eval.ts", "../src/eval/index.ts"],
  "sourcesContent": ["import _check from \"./check\";\nimport _eval from \"./eval\";\n\nexport const hashCode = (str: string): number => {\n  let hash = 0;\n  for (let i = 0; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + code;\n    hash &= hash;\n  }\n  return hash;\n};\n\nexport const check = _check;\nexport const parser = _eval;", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nconst TRUE = new Boolean(true);\nconst FALSE = new Boolean(false);\nconst BOOLEANS = [true, TRUE, false, FALSE];\n\nconst isNumber = (x: any) => {\n  return (\n    typeof x === \"number\"\n    || x instanceof Number\n    || typeof x === \"bigint\"\n    || x instanceof BigInt\n  );\n};\n\nconst isString = (x: any) => {\n  return (\n    typeof x === \"string\"\n    || x instanceof String\n  );\n};\n\nconst isBoolean = (x: any) => {\n  return (\n    typeof x === \"boolean\"\n    || x instanceof Boolean\n    || BOOLEANS.includes(x)\n  );\n};\n\nconst isFunction = (x: any) => {\n  return (\n    typeof x === \"function\"\n    || x instanceof Function\n  );\n};\n\nconst isObject = (x: any) => {\n  if (isNil(x)) {\n    return false;\n  }\n\n  return typeof x === \"object\";\n};\n\nconst isNil = (x: any) => {\n  return x === null || x === undefined;\n};\n\nconst isArray = (x: any) => {\n  return (\n    Array.isArray(x)\n    || x instanceof Array\n    || Object.prototype.toString.call(x) === \"[object Array]\"\n  );\n};\n\nconst isSet = (x: any) => {\n  return (\n    x instanceof Set\n    || Object.prototype.toString.call(x) === \"[object Set]\"\n  );\n};\n\nconst isIterable = (x: any) => {\n  // checks for null and undefined\n  if (isNil(x)) {\n    return false;\n  }\n  return isFunction(x[Symbol.iterator]);\n};\n\nconst isNumeric = (x: any) => {\n  if (isNumber(x)) {\n    return true;\n  }\n  if (!isString(x)) {\n    return false;\n  }\n  return !isNaN(x) && !isNaN(parseFloat(x));\n};\n\nconst isValidBoolean = (x: any) => {\n  if (isBoolean(x)) {\n    return true;\n  }\n\n  const isNum = isNumber(x);\n  const isStr = isString(x);\n  if (isNum || isStr) {\n    const alts = [\n      \"true\",\n      \"false\",\n      1,\n      0,\n      \"1\",\n      \"0\",\n      TRUE,\n      FALSE,\n      true,\n      false,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isStr) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isTrue = (x: any) => {\n  if (x && x.toString && x.toString() === \"true\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    const alts = [\n      true,\n      \"true\",\n      \"1\",\n      1,\n      TRUE,\n    ];\n\n    if (alts.includes(x)) {\n      return true;\n    }\n\n    if (isString(x)) {\n      x = x.trim();\n      const len = Math.max(...alts.map((x) => x.toString().length));\n      if (x.length <= len && alts.includes(x.toLowerCase())) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst isFalse = (x: any) => {\n  if (x && x.toString && x.toString() === \"false\") {\n    return true;\n  }\n\n  if (isValidBoolean(x)) {\n    return !isTrue(x);\n  }\n\n  return false;\n};\n\n// @exports\nexport default {\n  isNumber,\n  isString,\n  isBoolean,\n  isFunction,\n  isObject,\n  isNumeric,\n  isValidBoolean,\n  isTrue,\n  isFalse,\n  isArray,\n  isSet,\n  isIterable,\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code is based on the emoteJAM project (https://github.com/tsoding/emoteJAM), \n// which is licensed under the MIT License. \n// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>\n\nimport check from \"../check\";\n\nconst __SAVE = \"$B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B_B\";\n\nexport const BIN_PREC = {\n  \"0\": \"PREC0\",\n  \"1\": \"PREC1\",\n  \"2\": \"COUNT_PRECS\",\n  \"PREC0\": 0,\n  \"PREC1\": 1,\n  \"COUNT_PRECS\": 2\n} as const;\nObject.freeze(BIN_PREC);\nObject.seal(BIN_PREC);\n\nexport const BINARY_OPS = {\n  \"+\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}+${rhs}`;\n      }\n      return lhs + rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"-\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}-${rhs}`;\n      }\n      return lhs - rhs;\n    },\n    prec: BIN_PREC.PREC0,\n  },\n  \"*\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}*${rhs}`;\n      }\n      return lhs * rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"/\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}/${rhs}`;\n      }\n      return lhs / rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n  \"%\": {\n    func: (lhs: any, rhs: any) => {\n      if (![lhs, rhs].every(check.isNumber)) {\n        return `${lhs}%${rhs}`;\n      }\n      return lhs % rhs;\n    },\n    prec: BIN_PREC.PREC1\n  },\n};\n\nexport const UNARY_OPS = {\n  \"-\": (arg: number) => -arg,\n};\n\nexport type UnaryOpsKeys = keyof typeof UNARY_OPS;\nexport type BinaryOpsKeys = keyof typeof BINARY_OPS;\nconst ____IGNORE: unknown = 42;\nconst ___TOF = typeof ____IGNORE;\nexport type TypeOf = typeof ___TOF;\nexport type AnyFn = (...args: any) => any;\nexport type ContextVarsVarType = any;\nexport type ContextFuncs = {\n  [key: string]: AnyFn,\n};\nexport type ContextVars = {\n  [key: string]: ContextVarsVarType,\n};\nexport type EvalContext = {\n  funcs?: ContextFuncs,\n  vars?: ContextVars,\n};\nexport type Expression = {\n  kind: \"funcall\" | \"unary_op\" | \"symbol\" | \"binary_op\",\n  payload: {\n    name?: string,\n    op?: string,\n    value?: string,\n    operand?: Expression,\n    rhs?: Expression,\n    lhs?: Expression,\n    args?: Expression[],\n  },\n};\n\nexport class Lexer {\n  constructor(\n    private src: string,\n    private hist: string[] = [],\n    private syntax: string = \"(),\",\n    public alreadyCrashed: boolean = false,\n  ) { }\n\n  nextToken(): string | null {\n    const token = this.next();\n    if (token !== null) {\n      this.unnext(token);\n    }\n    return token;\n  }\n\n  lastToken(): string | undefined {\n    return this.hist[this.hist.length - 1];\n  }\n\n  unnext(token: string) {\n    this.src = token + this.src;\n    this.hist.pop();\n  }\n\n  next(): string | null {\n    this.src = this.src.trimStart();\n    if (this.src.length == 0) {\n      return null;\n    }\n    const isTokenBreak = (c: string) => {\n      return (\n        c in BINARY_OPS\n        || c in UNARY_OPS\n        || this.syntax.includes(c)\n      );\n    };\n\n    const isDouble = this.src.startsWith(\"\\\"\");\n    const isSingle = this.src.startsWith(\"'\");\n    const isSOFStr = isDouble || isSingle;\n    const strEnd = this.src.indexOf(isDouble ? \"\\\"\" : \"'\", 1);\n    if (isSOFStr && strEnd > 0) {\n      const token = this.src.slice(0, strEnd + 1);\n      this.src = this.src.slice(strEnd + 1);\n      this.hist.push(token);\n      return token;\n    }\n\n    if (isTokenBreak(this.src[0])) {\n      const token = this.src[0];\n      this.src = this.src.slice(1);\n      this.hist.push(token);\n      return token;\n    }\n    for (let i = 0; i < this.src.length; ++i) {\n      if (isTokenBreak(this.src[i]) || this.src[i] == \" \") {\n        const token = this.src.slice(0, i);\n        this.src = this.src.slice(i);\n        this.hist.push(token);\n        return token;\n      }\n    }\n    const token = this.src;\n    this.hist.push(token);\n    this.src = \"\";\n    return token;\n  }\n\n  hasNext(): boolean {\n    const token = this.next();\n    const valid = token !== null;\n    if (valid) {\n      this.unnext(token);\n    }\n    return valid;\n  }\n\n  spaceAfterToken(): string {\n    const token = this.next();\n    const valid = token !== null;\n    \n    if (valid && this.src) {\n      const spaceCount = this.src.length - this.src.trimStart().length;\n      if (spaceCount > 0) {\n        this.unnext(token);\n        return \" \".repeat(spaceCount);\n      }\n    }\n    if (valid) {\n      this.unnext(token);\n    }\n    return \"\";\n  }\n}\n\nexport const parsePrimary = (lexer: Lexer): Expression => {\n  let token = lexer.next();\n  if (token !== null) {\n    if (token in UNARY_OPS) {\n      const operand = parseExpr(lexer);\n      return {\n        \"kind\": \"unary_op\",\n        \"payload\": {\n          \"op\": token,\n          \"operand\": operand,\n        },\n      };\n    }\n    else if (token === \"(\") {\n      const expr = parseExpr(lexer);\n      token = lexer.next();\n      if (token === __SAVE) {\n        token = lexer.next();\n      }\n      if (token !== \")\") {\n        throw new Error(\"Expected ')' but got '\" + token + \"'\");\n      }\n      return expr;\n    }\n    else if (token === \")\") {\n      if (!lexer.alreadyCrashed) {\n        lexer.alreadyCrashed = true;\n        lexer.unnext(\",\" + __SAVE + \")\");\n        return parsePrimary(lexer);\n      }\n\n      throw new Error(\"No primary expression starts with ')'\");\n    }\n    else {\n      let nextToken = lexer.next();\n      if (nextToken === \"(\") {\n        const args: Expression[] = [];\n        nextToken = lexer.next();\n        if (nextToken === \")\") {\n          return {\n            \"kind\": \"funcall\",\n            \"payload\": {\n              \"name\": token,\n              \"args\": args,\n            }\n          };\n        }\n        if (nextToken === null) {\n          throw Error(\"Unexpected end of input\");\n        }\n        lexer.unnext(nextToken);\n        args.push(parseExpr(lexer));\n        nextToken = lexer.next();\n\n        // Don't @me >-<\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        while (nextToken == \",\") {\n          args.push(parseExpr(lexer));\n          nextToken = lexer.next();\n          if (nextToken === __SAVE) {\n            nextToken = lexer.next();\n          }\n        }\n        if (nextToken === __SAVE) {\n          nextToken = lexer.next();\n        }\n        if (nextToken !== \")\") {\n          throw Error(\"Expected ')' but got '\" + nextToken + \"'\");\n        }\n        return {\n          \"kind\": \"funcall\",\n          \"payload\": {\n            \"name\": token,\n            \"args\": args,\n          }\n        };\n      } else {\n        if (nextToken !== null) {\n          lexer.unnext(nextToken);\n        }\n        return {\n          \"kind\": \"symbol\",\n          \"payload\": {\n            \"value\": token\n          }\n        };\n      }\n    }\n  } else {\n    throw new Error(\"Expected primary expression but reached the end of the input\");\n  }\n};\n\nexport const parseExpr = (lexer: Lexer, prec: number = BIN_PREC.PREC0): Expression => {\n  if (prec >= BIN_PREC.COUNT_PRECS) {\n    return parsePrimary(lexer);\n  }\n  const lhs = parseExpr(lexer, prec + 1);\n  const opToken = lexer.next();\n  if (opToken !== null) {\n    if (opToken in BINARY_OPS && BINARY_OPS[opToken as BinaryOpsKeys].prec == prec) {\n      const rhs = parseExpr(lexer, prec);\n      return {\n        \"kind\": \"binary_op\",\n        \"payload\": {\n          \"op\": opToken,\n          \"lhs\": lhs,\n          \"rhs\": rhs,\n        }\n      };\n    }\n    else {\n      lexer.unnext(opToken);\n    }\n  }\n  return lhs;\n};\n\n// export const compileExpr = (src: string) => {\n//   const lexer = new Lexer(src);\n//   const result = parseExpr(lexer);\n//   const token = lexer.next();\n//   if (token !== null) {\n//     console.log(typeof (token));\n//     console.log(token);\n//     throw new Error(\"Unexpected token '\" + token + \"'\");\n//   }\n//   return result;\n// };\n\nexport const runExpr = (expr: Expression, ctx: EvalContext = {}): any => {\n  console.assert(check.isObject(expr));\n  switch (expr.kind) {\n  case \"symbol\": {\n    const symbol = expr.payload;\n    const value = symbol.value;\n    const number = Number(value);\n    if (isNaN(number)) {\n      if (ctx.vars && value && value in ctx.vars) {\n        return ctx.vars[value];\n      }\n      if (value?.startsWith(\"$\")) {\n        console.warn(\"WARN: Unknown variable '\" + value + \"'\");\n      }\n      return value;\n    } else {\n      return number;\n    }\n  }\n  case \"unary_op\": {\n    const unary_op = expr.payload;\n    const op = unary_op?.op;\n    const operand = unary_op?.operand;\n    if (op && op in UNARY_OPS) {\n      if (operand === undefined) {\n        throw new Error(\"operand needs to be an object not undefined\");\n      }\n      return UNARY_OPS[op as UnaryOpsKeys](runExpr(operand, ctx));\n    }\n    throw new Error(\"Unknown unary operator '\" + unary_op.op + \"'\");\n  }\n  case \"binary_op\": {\n    const binary_op = expr.payload;\n    const op = binary_op?.op;\n    const lhs = binary_op?.lhs;\n    const rhs = binary_op?.rhs;\n    if (op && op in BINARY_OPS) {\n      if (lhs === undefined) {\n        throw new Error(\"lhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      if (rhs === undefined) {\n        throw new Error(\"rhs operand needs to be an object not undefined: \" + `lhs=${lhs} :: rhs=${rhs}`);\n      }\n      return BINARY_OPS[op as BinaryOpsKeys].func(runExpr(lhs, ctx), runExpr(rhs, ctx));\n    }\n\n    throw new Error(\"Unknown binary operator '\" + op + \"'\");\n  }\n  case \"funcall\": {\n    const funcall = expr.payload;\n    const name = funcall.name;\n    const args = funcall.args;\n    if (ctx.funcs && name !== undefined && args !== undefined && name in ctx.funcs) {\n      let _a;\n      return (\n        (_a = ctx.funcs)[name].apply(\n          _a,\n          args.map((arg) => runExpr(arg, ctx))\n        )\n      );\n    }\n    if (name?.startsWith(\"$\")) {\n      console.warn(\"WARN: Unknown function '\" + name + \"'\");\n    }\n    const params = args\n      ?.map((x) => x?.payload?.value)\n      .map((x) => check.isObject(x) ? JSON.stringify(x) : x)\n      .join(\", \");\n    return `${name}(${params || \"\"})`;\n  }\n  default: {\n    throw new Error(\"Unexpected AST node '\" + expr.kind + \"'\");\n  }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport check from \"../check\";\nimport { type EvalContext, type ContextFuncs, type TypeOf, Lexer, parseExpr, runExpr } from \"./eval\";\n\nconst fixString = (x: string) => {\n  if (check.isString(x)) {\n    if (x.startsWith(\"\\\"\") && x.endsWith(\"\\\"\")) {\n      x = x.substring(1, x.length - 1);\n    } else if (x.startsWith(\"'\") && x.endsWith(\"'\")) {\n      x = x.substring(1, x.length - 1);\n    }\n  }\n\n  return x;\n};\n\nconst wrapCtxFuncs = (mut_ctx: EvalContext) => {\n  const _f = mut_ctx?.funcs;\n  if (_f && check.isObject(_f)) {\n    const f = { ..._f };\n    const updated: ContextFuncs = {};\n    Object\n      .keys(f)\n      .forEach((k) => {\n        updated[k] = (...args: any[]) => {\n          args = args.map(fixString);\n          return f[k](...args);\n        };\n      });\n\n    mut_ctx.funcs = updated;\n  }\n  return mut_ctx;\n};\n\nconst builtinFunctions = () => {\n  const $abs = (x: any): number => Math.abs(x);\n  const $all = (...args: any[]): boolean => {\n    return args.map($bool).every((x) => x === true);\n  };\n  const $any = (...args: any[]): boolean => {\n    return args.map($bool).some((x) => x === true);\n  };\n\n  const $bool = (x: any): boolean => {\n    if (check.isValidBoolean(x)) {\n      return check.isTrue(x);\n    }\n\n    return !!x && $isset(x);\n  };\n  const $float = (x: any): number => parseFloat(x);\n  const $str = (x: any): string => {\n    if (check.isObject(x)) {\n      x = JSON.stringify(x, null, 0);\n    }\n\n    if (!check.isString(x)) {\n      x = x.toString ? x.toString() : `${x}`;\n    }\n\n    return x;\n  };\n\n  const $format = (fmt: string, ...args: any[]): string => {\n    if (!check.isString(fmt) || args.length === 0) {\n      return fmt;\n    }\n    args.map($str).forEach((variable, index) => {\n      const template = `{${index}}`;\n      while (fmt.includes(template)) {\n        fmt = fmt.replace(template, variable);\n      }\n    });\n\n    return fmt;\n  };\n\n  // const $hash = (x: string): number => {\n  //   x = $str(x);\n  //   let hash = 0;\n  //   for (let i = 0; i < x.length; ++i) {\n  //     const code = x.charCodeAt(i);\n  //     hash = ((hash << 5) - hash) + code;\n  //     hash &= hash;\n  //   }\n  //   return hash;\n  // };\n\n  const $if = (condition: boolean, ifTrue: any, ifFalse: any) => {\n    return $bool(condition) ? ifTrue : ifFalse;\n  };\n\n  const $int = (x: any): number => parseInt(x);\n  const $isinstance = (x: any, ...types: TypeOf[]): boolean => {\n    const xType = $type(x);\n    return types.map($str).some((t) => xType === t);\n  };\n\n  const $tisstring = (x: any) => {\n    return $isinstance(x, \"string\");\n  };\n  const $tisnumber = (x: any) => {\n    return $isinstance(x, \"number\", \"bigint\");\n  };\n  const $tisundefined = (x: any) => {\n    return $isinstance(x, \"undefined\");\n  };\n  const $tisobject = (x: any) => {\n    return $isinstance(x, \"object\");\n  };\n  const $tisboolean = (x: any) => {\n    return $isinstance(x, \"boolean\");\n  };\n  const $isnil = (x: any) => {\n    return x === null || x === undefined;\n  };\n\n  const $endsWith = (x: any, searchString: string, endPos?: number) => {\n    x = $str(x);\n    searchString = $str(searchString);\n    return x.endsWith(searchString, endPos);\n  };\n  const $startsWith = (x: any, searchString: string, pos?: number) => {\n    return $str(x).startsWith(searchString, pos);\n  };\n  const $lower = (x: any) => {\n    return $str(x).toLowerCase();\n\n  };\n  const $upper = (x: any) => {\n    return $str(x).toUpperCase();\n  };\n\n  const $len = (x: any): number => {\n    return $str(x).length;\n  };\n\n  const $max = (...args: any[]): any => {\n    return Math.max(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n  const $min = (...args: any[]): any => {\n    return Math.min(\n      ...args\n        .map($str)\n        .map($float)\n        .filter((x) => !isNaN(x))\n    );\n  };\n\n  const $pow = (a: number, b: number) => Math.pow(a, b);\n  const $round = (a: number) => Math.round(a);\n  const $math = (key: string, ...args: any[]) => {\n    try {\n      const intrinsic = (Math as any)[key];\n      const result = check.isFunction(intrinsic) ? intrinsic(...args) : intrinsic;\n      if (result) {\n        return result;\n      }\n    } catch (error) {\n      console.error(error);\n    }\n\n    const argv = args.join(\", \");\n    return `Math.${key}${!argv ? \"\" : \"(\" + argv + \")\"}`;\n  };\n  const $concat = (...args: any[]) => {\n    return args.map($str).join(\"\");\n  };\n  const $substring = (x: string, start: number, end?: number) => {\n    const str = $str(x);\n    if (start === undefined || !check.isNumber(start) || start < 0) {\n      start = 0;\n    }\n    if (end === undefined || !check.isNumber(start) || end > str.length) {\n      end = str.length;\n    }\n    return str.substring(start, end);\n\n  };\n  const $type = (x: any) => typeof x;\n  const $getattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back \n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n      \n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          }\n        });\n    });\n\n    \n    return ptr;\n  };\n\n  const $hasattr = (obj: any, ...path: string[]) => {\n    let ptr = obj;\n    let result = true;\n    path.filter(check.isString).forEach((literalKey) => {\n      // Split key into parts on '.'\n      let keys = literalKey.split(\".\");\n\n      // Check if first attr exists if not revert back \n      // to original key\n      if (!ptr[keys[0]]) {\n        keys = [literalKey];\n      }\n      \n      keys\n        .filter((x) => !!x)\n        .forEach((key) => {\n          if (ptr && key && ptr[key]) {\n            ptr = ptr[key];\n          } else {\n            result = false;\n          }\n        });\n    });\n\n    \n    return result;\n  };\n  const $isset = (obj: any) => {\n    return !$str(obj).startsWith(\"$\");\n  };\n\n  const $includes = (x: any, value: any) => {\n    if (x) {      \n      if (x.includes && check.isFunction(x.includes)) {\n        return x.includes(value);\n      }\n\n      if (x.has && check.isFunction(x.has)) {\n        return x.has(value);\n      }\n    }\n\n    return false;\n  };\n\n  return {\n    $if,\n    $abs,\n    $all,\n    $any,\n    $bool,\n    $float,\n    $str,\n    $format,\n    $int,\n    $isnil,\n    $isinstance,\n    $tisstring,\n    $tisnumber,\n    $tisboolean,\n    $tisundefined,\n    $tisobject,\n    $len,\n    $max,\n    $min,\n    $pow,\n    $round,\n    $substring,\n    $type,\n    $math,\n    $getattr,\n    $concat,\n    $hasattr,\n    $isset,\n    $includes,\n    $endsWith,\n    $startsWith,\n    $lower,\n    $upper,\n  };\n};\n\nconst parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  return sentence\n    .split(\"\\n\")\n    .map((line) => _parseSentence(line , _ctx))\n    .join(\"\\n\");\n};\n\nconst _parseSentence = (sentence: string, _ctx: EvalContext = {}) => {\n  const ctx = wrapCtxFuncs({/*clone*/..._ctx });\n  const lex = new Lexer(sentence);\n\n  const builder = [];\n  while (lex.hasNext()) {\n    const _restore = lex.spaceAfterToken();\n    let restoreSpace = \"\";\n    const expr = parseExpr(lex);\n    let word = expr.payload.value;\n    const cutHist = [];\n    if (word && check.isString(word) && word.startsWith(\"$\")) {\n      restoreSpace = _restore;\n      let isPeriod = word.endsWith(\".\");\n      let isExcla = word.endsWith(\"!\");\n      while (word && (isPeriod || isExcla)) {\n        word = word.substring(0, word.length - 1);\n        \n        if (isPeriod) {\n          cutHist.push(\".\");\n        } else if (isExcla) {\n          cutHist.push(\"!\");\n        }\n        isPeriod = word.endsWith(\".\");\n        isExcla = word.endsWith(\"!\");\n      }\n\n      if (cutHist.length !== 0) {\n        expr.payload.value = word;\n      }  \n    }\n    const isFuncCall = expr.kind === \"funcall\";\n    const isSymbol = expr.kind === \"symbol\";\n    const resolved = runExpr(expr, ctx);\n    const append = cutHist.join(\"\");\n    builder.push(resolved + append + restoreSpace);\n    \n    const isVar = lex.lastToken()?.startsWith(\"$\");\n    const commaLoc = builder.lastIndexOf(\",\") - 1;\n    if (lex.lastToken() === \",\" && builder[commaLoc] === \" \") {\n      builder.splice(commaLoc, 1);\n    }\n\n    if (isFuncCall && lex.nextToken() !== \"!\") {\n      builder.push(\" \");\n    }\n\n    if (!(isFuncCall || (isSymbol && isVar))) {\n      builder.push(\" \");\n    }\n  }\n\n  return builder.join(\"\").trim();\n};\n\n// @exports\nexport type BuiltInFunction = ReturnType<typeof builtinFunctions>;\nexport type BuiltInFunctionKey = keyof BuiltInFunction;\nexport type Context = EvalContext;\n\nexport default {\n  builtinFunctions,\n  parseSentence,\n};\n"],
  "mappings": "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",
  "names": ["x", "token"]
}
